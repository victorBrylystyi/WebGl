{"map":"{\"version\":3,\"sources\":[\"bundle.js\"],\"names\":[\"modules\",\"installedModules\",\"__webpack_require__\",\"moduleId\",\"exports\",\"module\",\"i\",\"l\",\"call\",\"m\",\"c\",\"d\",\"name\",\"getter\",\"o\",\"Object\",\"defineProperty\",\"enumerable\",\"get\",\"r\",\"Symbol\",\"toStringTag\",\"value\",\"t\",\"mode\",\"__esModule\",\"ns\",\"create\",\"key\",\"bind\",\"n\",\"object\",\"property\",\"prototype\",\"hasOwnProperty\",\"p\",\"s\",\"__webpack_exports__\",\"eval\"],\"mappings\":\"CAAS,SAAUA,GAET,IAAIC,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAJ,EAAQG,GAAUK,KAAKH,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBO,EAAIT,EAGxBE,EAAoBQ,EAAIT,EAGxBC,EAAoBS,EAAI,SAASP,EAASQ,EAAMC,GAC3CX,EAAoBY,EAAEV,EAASQ,IAClCG,OAAOC,eAAeZ,EAASQ,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEX,EAAoBiB,EAAI,SAASf,GACX,oBAAXgB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeZ,EAASgB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeZ,EAAS,aAAc,CAAEkB,OAAO,KAQvDpB,EAAoBqB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQpB,EAAoBoB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFAzB,EAAoBiB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOpB,EAAoBS,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRxB,EAAoB4B,EAAI,SAASzB,GAChC,IAAIQ,EAASR,GAAUA,EAAOoB,WAC7B,WAAwB,OAAOpB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBS,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRX,EAAoBY,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG9B,EAAoBiC,EAAI,GAIjBjC,EAAoBA,EAAoBkC,EAAI,GAnFpD,CAsFC,CAEJ,SAAU/B,OAAQgC,oBAAqBnC,qBAE7C,aACAoC,KAAK\"}","code":"!function(g){var I={};function C(A){if(I[A])return I[A].exports;var t=I[A]={i:A,l:!1,exports:{}};return g[A].call(t.exports,t,t.exports,C),t.l=!0,t.exports}C.m=g,C.c=I,C.d=function(g,I,A){C.o(g,I)||Object.defineProperty(g,I,{enumerable:!0,get:A})},C.r=function(g){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(g,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(g,\"__esModule\",{value:!0})},C.t=function(g,I){if(1&I&&(g=C(g)),8&I)return g;if(4&I&&\"object\"==typeof g&&g&&g.__esModule)return g;var A=Object.create(null);if(C.r(A),Object.defineProperty(A,\"default\",{enumerable:!0,value:g}),2&I&&\"string\"!=typeof g)for(var t in g)C.d(A,t,function(I){return g[I]}.bind(null,t));return A},C.n=function(g){var I=g&&g.__esModule?function(){return g.default}:function(){return g};return C.d(I,\"a\",I),I},C.o=function(g,I){return Object.prototype.hasOwnProperty.call(g,I)},C.p=\"\",C(C.s=0)}([function(module,__webpack_exports__,__webpack_require__){\"use strict\";eval(\"// ESM COMPAT FLAG\\n__webpack_require__.r(__webpack_exports__);\\n\\n// CONCATENATED MODULE: ./src/Coordinates3D.js\\n\\nclass Coordinates3D {\\n    constructor (x=0,y=0,z=0){\\n        this.x=x;\\n        this.y=y;\\n        this.z=z;\\n    }\\n    clone(){\\n        return new Coordinates3D(this.x,this.y,this.z);\\n    }\\n}\\n\\n// CONCATENATED MODULE: ./src/math/Matrix.js\\n\\n\\nclass Matrix_Matrix { \\n      window(data){\\n        let w = new Coordinates3D(data.x,data.y,data.z);\\n        return [\\n          2 / w.x, 0, 0, 0,\\n          0, -2 / w.y, 0, 0,\\n          0, 0, 2 / w.z, 0,   \\n        -1, 1, 0, 1,\\n      ];\\n      }\\n      perspective(data){\\n        let fovInRadians = data.fov * Math.PI/180;\\n        let f = Math.tan(Math.PI * 0.5 - 0.5 * fovInRadians);\\n        let rangeInv = 1.0 / (data.zNear - data.zFar);\\n        let a = f / data.aspect;\\n        let b = (data.zNear + data.zFar) * rangeInv;\\n        let c = data.zNear * data.zFar * rangeInv * 2.0;\\n\\n        return [\\n          a, 0,  0, 0,\\n          0, f, 0, 0,\\n          0, 0,  b, -1,\\n          0, 0,  c, 0,\\n        ];\\n      }\\n      ortographic(data){\\n        let w = data.right - data.left;\\n        let h = data.top - data.bottom;\\n        let d = data.far - data.near;\\n\\n        let tx = -((data.right + data.left)/w);\\n        let ty = -((data.top + data.bottom)/h);\\n        let tz = -((data.far + data.near)/d);\\n        return [\\n          2 / w, 0,     0,      0,\\n          0,     2 / h, 0,      0,\\n          0,     0,     -2 / d, 0,   \\n          tx,    ty,    tz,     1,\\n      ];\\n      }\\n      scale(data){\\n        let s = new Coordinates3D(data.x,data.y,data.z)\\n        return [\\n          s.x,0,0,0,\\n          0,s.y,0,0,\\n          0,0,s.z,0,\\n          0,0,0,1\\n        ];\\n      }\\n      translate(data=0){\\n        let t = new Coordinates3D(data.x,data.y,data.z);\\n        return[\\n          1,0,0,0,\\n          0,1,0,0,\\n          0,0,1,0,\\n          t.x,t.y,t.z,1\\n        ];\\n      }\\n      xRotation(a=0) {\\n        let c = Math.cos(a);\\n        let s = Math.sin(a);\\n        return [\\n          1, 0, 0, 0,\\n          0, c, -s, 0,\\n          0, s, c, 0,\\n          0, 0, 0, 1,\\n        ];\\n      }\\n      yRotation (a=0) {\\n        let c = Math.cos(a);\\n        let s = Math.sin(a);\\n        return [\\n          c, 0, s, 0,\\n          0, 1, 0, 0,\\n          -s, 0, c, 0,\\n          0, 0, 0, 1,\\n        ];\\n      }\\n      zRotation(a=0){\\n        return [\\n          Math.cos(a), -Math.sin(a),    0,    0,\\n          Math.sin(a),  Math.cos(a),    0,    0,\\n               0,       0,    1,    0,\\n               0,       0,    0,    1\\n        ];\\n      }\\n      multiplyMatrixAndPoint(matrix, point) {\\n        // Give a simple variable name to each part of the matrix, a column and row number\\n        let c0r0 = matrix[0], c1r0 = matrix[1], c2r0 = matrix[2], c3r0 = matrix[3];\\n        let c0r1 = matrix[4], c1r1 = matrix[5], c2r1 = matrix[6], c3r1 = matrix[7];\\n        let c0r2 = matrix[8], c1r2 = matrix[9], c2r2 = matrix[10], c3r2 = matrix[11];\\n        let c0r3 = matrix[12], c1r3 = matrix[13], c2r3 = matrix[14], c3r3 = matrix[15];\\n      \\n        // Now set some simple names for the point\\n        let x = point[0];\\n        let y = point[1];\\n        let z = point[2];\\n        let w = point[3];\\n      \\n        // Multiply the point against each part of the 1st column, then add together\\n        let resultX = (x * c0r0) + (y * c0r1) + (z * c0r2) + (w * c0r3);\\n      \\n        // Multiply the point against each part of the 2nd column, then add together\\n        let resultY = (x * c1r0) + (y * c1r1) + (z * c1r2) + (w * c1r3);\\n      \\n        // Multiply the point against each part of the 3rd column, then add together\\n        let resultZ = (x * c2r0) + (y * c2r1) + (z * c2r2) + (w * c2r3);\\n      \\n        // Multiply the point against each part of the 4th column, then add together\\n        let resultW = (x * c3r0) + (y * c3r1) + (z * c3r2) + (w * c3r3);\\n      \\n        return [resultX, resultY, resultZ, resultW];\\n      }\\n      multiply(a,b){\\n        var a00 = a[0 * 4 + 0];\\n        var a01 = a[0 * 4 + 1];\\n        var a02 = a[0 * 4 + 2];\\n        var a03 = a[0 * 4 + 3];\\n        var a10 = a[1 * 4 + 0];\\n        var a11 = a[1 * 4 + 1];\\n        var a12 = a[1 * 4 + 2];\\n        var a13 = a[1 * 4 + 3];\\n        var a20 = a[2 * 4 + 0];\\n        var a21 = a[2 * 4 + 1];\\n        var a22 = a[2 * 4 + 2];\\n        var a23 = a[2 * 4 + 3];\\n        var a30 = a[3 * 4 + 0];\\n        var a31 = a[3 * 4 + 1];\\n        var a32 = a[3 * 4 + 2];\\n        var a33 = a[3 * 4 + 3];\\n        var b00 = b[0 * 4 + 0];\\n        var b01 = b[0 * 4 + 1];\\n        var b02 = b[0 * 4 + 2];\\n        var b03 = b[0 * 4 + 3];\\n        var b10 = b[1 * 4 + 0];\\n        var b11 = b[1 * 4 + 1];\\n        var b12 = b[1 * 4 + 2];\\n        var b13 = b[1 * 4 + 3];\\n        var b20 = b[2 * 4 + 0];\\n        var b21 = b[2 * 4 + 1];\\n        var b22 = b[2 * 4 + 2];\\n        var b23 = b[2 * 4 + 3];\\n        var b30 = b[3 * 4 + 0];\\n        var b31 = b[3 * 4 + 1];\\n        var b32 = b[3 * 4 + 2];\\n        var b33 = b[3 * 4 + 3];\\n        return [\\n          b00 * a00 + b01 * a10 + b02 * a20 + b03 * a30,\\n          b00 * a01 + b01 * a11 + b02 * a21 + b03 * a31,\\n          b00 * a02 + b01 * a12 + b02 * a22 + b03 * a32,\\n          b00 * a03 + b01 * a13 + b02 * a23 + b03 * a33,\\n          b10 * a00 + b11 * a10 + b12 * a20 + b13 * a30,\\n          b10 * a01 + b11 * a11 + b12 * a21 + b13 * a31,\\n          b10 * a02 + b11 * a12 + b12 * a22 + b13 * a32,\\n          b10 * a03 + b11 * a13 + b12 * a23 + b13 * a33,\\n          b20 * a00 + b21 * a10 + b22 * a20 + b23 * a30,\\n          b20 * a01 + b21 * a11 + b22 * a21 + b23 * a31,\\n          b20 * a02 + b21 * a12 + b22 * a22 + b23 * a32,\\n          b20 * a03 + b21 * a13 + b22 * a23 + b23 * a33,\\n          b30 * a00 + b31 * a10 + b32 * a20 + b33 * a30,\\n          b30 * a01 + b31 * a11 + b32 * a21 + b33 * a31,\\n          b30 * a02 + b31 * a12 + b32 * a22 + b33 * a32,\\n          b30 * a03 + b31 * a13 + b32 * a23 + b33 * a33,\\n        ];   \\n      }\\n      invert(a) {\\n      let out = [];\\n      let a00 = a[0],\\n        a01 = a[1],\\n        a02 = a[2],\\n        a03 = a[3];\\n      let a10 = a[4],\\n        a11 = a[5],\\n        a12 = a[6],\\n        a13 = a[7];\\n      let a20 = a[8],\\n        a21 = a[9],\\n        a22 = a[10],\\n        a23 = a[11];\\n      let a30 = a[12],\\n        a31 = a[13],\\n        a32 = a[14],\\n        a33 = a[15];\\n    \\n      let b00 = a00 * a11 - a01 * a10;\\n      let b01 = a00 * a12 - a02 * a10;\\n      let b02 = a00 * a13 - a03 * a10;\\n      let b03 = a01 * a12 - a02 * a11;\\n      let b04 = a01 * a13 - a03 * a11;\\n      let b05 = a02 * a13 - a03 * a12;\\n      let b06 = a20 * a31 - a21 * a30;\\n      let b07 = a20 * a32 - a22 * a30;\\n      let b08 = a20 * a33 - a23 * a30;\\n      let b09 = a21 * a32 - a22 * a31;\\n      let b10 = a21 * a33 - a23 * a31;\\n      let b11 = a22 * a33 - a23 * a32;\\n    \\n      // Calculate the determinant\\n      let det =\\n        b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;\\n    \\n      if (!det) {\\n        return null;\\n      }\\n      det = 1.0 / det;\\n    \\n      out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;\\n      out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;\\n      out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;\\n      out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;\\n      out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;\\n      out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;\\n      out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;\\n      out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;\\n      out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;\\n      out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;\\n      out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;\\n      out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;\\n      out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;\\n      out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;\\n      out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;\\n      out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;\\n    \\n      return out;\\n      }\\n      transpose(a) {\\n        // If we are transposing ourselves we can skip a few steps but have to cache some values\\n        let out = [];\\n\\n          out[0] = a[0];\\n          out[1] = a[4];\\n          out[2] = a[8];\\n          out[3] = a[12];\\n          out[4] = a[1];\\n          out[5] = a[5];\\n          out[6] = a[9];\\n          out[7] = a[13];\\n          out[8] = a[2];\\n          out[9] = a[6];\\n          out[10] = a[10];\\n          out[11] = a[14];\\n          out[12] = a[3];\\n          out[13] = a[7];\\n          out[14] = a[11];\\n          out[15] = a[15];\\n        \\n      \\n        return out;\\n      }\\n      multiplyToModel(dataPosition,dataScale,dataRotation){\\n        let modelMatrix = this.multiply(this.translate(dataPosition),this.xRotation(dataRotation.x));\\n            modelMatrix = this.multiply(modelMatrix,this.yRotation(dataRotation.y));\\n            modelMatrix = this.multiply(modelMatrix,this.zRotation(dataRotation.z));\\n            modelMatrix = this.multiply(modelMatrix,this.scale(dataScale));\\n        return modelMatrix;\\n      }\\n      invertModelMatrix(dataPosition,dataScale,dataRotation){\\n        return this.invert(this.multiplyToModel(dataPosition,dataScale,dataRotation));\\n      }\\n      normalize(v) {\\n        let dst = [];\\n        let length = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);\\n        // make sure we don't divide by 0.\\n        if (length > 0.00001) {\\n          dst[0] = v[0] / length;\\n          dst[1] = v[1] / length;\\n          dst[2] = v[2] / length;\\n        }\\n        return dst;\\n      }\\n}\\n\\n\\n\\n/*   // another variant create matrix \\n      createOrtographic(data){\\n        let left = data.left;\\n        let right = data.right;\\n        let top = data.top;\\n        let bottom = data.bottom;\\n        let near = data.near;\\n        let far = data.far;\\n\\n        let M = [];\\n\\n        let widthRatio  = 1.0 / (right - left);\\n        let heightRatio = 1.0 / (top - bottom);\\n        let depthRatio  = 1.0 / (far - near);\\n    \\n        let sx = 2 * widthRatio;\\n        let sy = 2 * heightRatio;\\n        let sz = -2 * depthRatio;\\n    \\n        let tx = -(right + left) * widthRatio;\\n        let ty = -(top + bottom) * heightRatio;\\n        let tz = -(far + near) * depthRatio;\\n    \\n        M[0] = sx;  M[4] = 0;   M[8] = 0;   M[12] = tx;\\n        M[1] = 0;   M[5] = sy;  M[9] = 0;   M[13] = ty;\\n        M[2] = 0;   M[6] = 0;   M[10] = sz; M[14] = tz;\\n        M[3] = 0;   M[7] = 0;   M[11] = 0;  M[15] = 1;\\n    \\n        return M;\\n      }\\n      createFrustum(left, right, bottom, top, near, far){\\n        let M = [];\\n        let sx = 2 * near / (right - left);\\n        var sy = 2 * near / (top - bottom);\\n  \\n        let c2 = - (far + near) / (far - near);\\n        let c1 = 2 * near * far / (near - far);\\n\\n        let A = (right + left) / (right - left);\\n        let B = (top + bottom) / (top - bottom);\\n  \\n        let tx = -near * (left + right) / (right - left);\\n        let ty = -near * (bottom + top) / (top - bottom);\\n  \\n        M[0] = sx; M[4] = 0;  M[8] = 0;    M[12] = tx;\\n        M[1] = 0;  M[5] = -sy; M[9] = 0;    M[13] = ty;\\n        M[2] = 0;  M[6] = 0;  M[10] = c2;  M[14] = c1;\\n        M[3] = 0;  M[7] = 0;  M[11] = -1;  M[15] = 0;\\n\\n        return M;\\n      }\\n      createPerspective(data){\\n       let fovy = data.fov;\\n       let aspect = data.aspect;\\n       let near = data.zNear;\\n       let far = data.zFar;\\n       \\n       let half_fovy = (fovy * Math.PI/180) / 2;\\n\\n       let top = near * Math.tan(half_fovy);\\n       let bottom = -top;\\n       let right = top * aspect;\\n       let left = -right;\\n \\n       return this.createFrustum(left, right, bottom, top, near, far);\\n      }\\n\\n*/\\n// CONCATENATED MODULE: ./src/program/ProgramRules.js\\n\\n\\nconst BLACK = [0.0, 0.0, 0.0];\\nconst WHITE = [1.0, 1.0, 1.0];\\nconst RED   = [1.0, 0.0, 0.0];\\nconst GREEN = [0.0, 1.0, 0.0];\\nconst BLUE  = [0.0, 0.0, 1.0];\\nconst YELLOW = [0.6,1.0,0.5];//(60,100%,50%)\\n\\nclass ProgramRules {\\n    constructor (gl,program,atrNames,unifNames){\\n        this.gl = gl;\\n        this.program = program;\\n        this.aNames = atrNames;\\n        this.uNames = unifNames;\\n        this.textAtrUpdt = true;\\n   \\n        this.getAtrLocations(this.gl,this.program,this.aNames);\\n        this.getUnifLocations(this.gl,this.program,this.uNames);\\n        this.createBuffers();\\n    }\\n    clearBuffers(){\\n        for (let key in this.aData){\\n            this.gl.deleteBuffer(this.buffers[key]);\\n        }\\n    }\\n    createBuffers(){\\n        this.buffers = {};\\n        for (let key in this.aData){\\n            this.buffers[key] = this.gl.createBuffer();\\n        }\\n    }\\n    setUniform(modelMatrix,invTrModelMatrix,rules,camera,light){\\n        for (let key in this.uData){\\n            switch (key){\\n                case 'modelMatrix':\\n                    this.gl.uniformMatrix4fv(this.uData[key], false, modelMatrix);\\n                break;\\n                case 'viewMatrix':\\n                    this.gl.uniformMatrix4fv(this.uData[key], false, camera.viewMatrix);\\n                break;\\n                case 'projMatrix':\\n                    this.gl.uniformMatrix4fv(this.uData[key], false, camera.projMatrix);\\n                break;\\n                case 'uSampler':\\n                    // Указываем шейдеру, что мы связали текстуру с текстурным регистром 0\\n                    this.gl.uniform1i(this.uData[key], 0);\\n                break;\\n                case 'v_color':\\n                    this.gl.uniform4fv(this.uData[key], rules.material.data.color);\\n                break;\\n// ------------------------------------------ LIGHT --------------------------------------------\\n                case 'u_ambIntensity': \\n                    this.gl.uniform1f(this.uData[key], light.ambient.intensity);\\n                break;\\n                case 'u_ambLightColor': \\n                    this.gl.uniform3fv(this.uData[key], light.ambient.color);\\n                break;\\n                case 'u_lightColor':  // light color \\n                //console.log(light.source.color);\\n                    this.gl.uniform3fv(this.uData[key], light.source.color);\\n                break;\\n                case 'u_intensity':   // light intensity  \\n                    this.gl.uniform1f(this.uData[key], light.source.intensity);\\n                break;\\n                case 'u_specularInt':   // spec intensity  \\n                //console.log(key);\\n                    this.gl.uniform1f(this.uData[key], light.source.specularInt);\\n                break;\\n                case 'u_specularColor': // specular color \\n                    this.gl.uniform3fv(this.uData[key], light.source.specularColor);//\\n                break;\\n                case 'invTranspModelMatrix':\\n                    this.gl.uniformMatrix4fv(this.uData[key], false, invTrModelMatrix);\\n                break;\\n                case 'u_lightWorldPosition': // position light \\n                    this.gl.uniform3fv(this.uData[key], [light.source.positionLight.x, light.source.positionLight.y, light.source.positionLight.z]); //[0, 0, 200]\\n                break;\\n                case 'u_viewWorldPosition': // position view \\n                    this.gl.uniform3fv(this.uData[key], Object.values(camera.position));\\n                break;\\n                case 'u_shininess':  \\n                    this.gl.uniform1f(this.uData[key], light.source.shiniess);\\n                break;\\n                case 'k_vertex':  \\n                    this.gl.uniform1f(this.uData[key], light.source.k_vertex);\\n                break;\\n\\n            };\\n        }\\n    }\\n    setAttribute(rules){\\n        for (let key in this.aData){\\n            switch (key){\\n                case 'a_normal':\\n                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(rules.geometry.cord.normals),this.gl.STATIC_DRAW);\\n\\n                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                    this.gl.vertexAttribPointer(this.aData[key], 3, this.gl.FLOAT, false, 0, 0);//gl.vertexAttribPointer(scene.objects[i].progRules.atrLoc[key2], bufSett[k], gl.FLOAT, false, 0, 0);\\n                    this.gl.enableVertexAttribArray(this.aData[key]);\\n                break;\\n                case 'a_position':\\n                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                    this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(rules.geometry.cord.vertex),this.gl.STATIC_DRAW);\\n    \\n                    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                    this.gl.vertexAttribPointer(this.aData[key], 3, this.gl.FLOAT, false, 0, 0);//gl.vertexAttribPointer(scene.objects[i].progRules.atrLoc[key2], bufSett[k], gl.FLOAT, false, 0, 0);\\n                    this.gl.enableVertexAttribArray(this.aData[key]);\\n                break;\\n                // case 'a_color':\\n                //     //console.log(material);\\n                //     this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                //     this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(),this.gl.STATIC_DRAW);\\n    \\n                //     //this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                //     this.gl.vertexAttribPointer(this.aData[key], 4, this.gl.FLOAT, false, 0, 0);\\n                //     this.gl.enableVertexAttribArray(this.aData[key]);\\n                // break;\\n                case 'aTextureCoord':\\n                    if (this.textAtrUpdt){\\n                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                        this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(rules.geometry.cord.map),this.gl.STATIC_DRAW);\\n\\n                        this.gl.bindTexture(this.gl.TEXTURE_2D, rules.material.texture);//rules.material.texture\\n    \\n                        // задаём параметры, чтобы можно было отрисовать изображение любого размера\\n                        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\\n                        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\\n                        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\\n                        this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\\n    \\n                            const num = 2;              // каждая координата состоит из 2 значений\\n                            const type = this.gl.FLOAT; // данные в буфере имеют тип 32 bit float\\n                            const normalize = false;    // не нормализуем\\n                            const stride = 0;           // сколько байт между одним набором данных и следующим\\n                            const offset = 0;           // стартовая позиция в байтах внутри набора данных\\n                        this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n                        this.gl.vertexAttribPointer(this.aData[key], num, type, normalize, stride, offset);\\n                        this.gl.enableVertexAttribArray(this.aData[key]);\\n    \\n                        // загружаем изображение в текстуру\\n                        this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, rules.material.data.map);\\n\\n                        //console.log('a');\\n                    } else {\\n                        //let texture = this.gl.createTexture();\\n                        \\n                        this.gl.activeTexture(this.gl.TEXTURE0);\\n                        this.gl.bindTexture(this.gl.TEXTURE_2D, rules.material.texture);//rules.material.texture\\n                    }\\n                    this.textAtrUpdt = false;\\n  \\n                break;\\n            };\\n        }\\n    }\\n    // updateAttribute(rules){\\n    //     for (let key in this.aData){\\n    //         switch (key){\\n    //             case 'a_normal':\\n    //                  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //                  this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(rules.geometry.cord.normals),this.gl.STATIC_DRAW);\\n\\n    //                  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //                  this.gl.vertexAttribPointer(this.aData[key], 3, this.gl.FLOAT, false, 0, 0);//gl.vertexAttribPointer(scene.objects[i].progRules.atrLoc[key2], bufSett[k], gl.FLOAT, false, 0, 0);\\n    //                  this.gl.enableVertexAttribArray(this.aData[key]);\\n    //             break;\\n    //             case 'a_position':\\n    //                  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //                  this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(rules.geometry.cord.vertex),this.gl.STATIC_DRAW);\\n    \\n    //                  this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //                  this.gl.vertexAttribPointer(this.aData[key], 3, this.gl.FLOAT, false, 0, 0);//gl.vertexAttribPointer(scene.objects[i].progRules.atrLoc[key2], bufSett[k], gl.FLOAT, false, 0, 0);\\n    //                  this.gl.enableVertexAttribArray(this.aData[key]);\\n    //             break;\\n    //             // case 'a_color':\\n    //             //     //console.log(material);\\n    //             //     this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //             //     this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(),this.gl.STATIC_DRAW);\\n    \\n    //             //     //this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //             //     this.gl.vertexAttribPointer(this.aData[key], 4, this.gl.FLOAT, false, 0, 0);\\n    //             //     this.gl.enableVertexAttribArray(this.aData[key]);\\n    //             // break;\\n    //             case 'aTextureCoord':\\n    //                  //this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //                  //this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array(rules.geometry.cord.map),this.gl.STATIC_DRAW);\\n\\n    //                  //this.gl.bindTexture(this.gl.TEXTURE_2D, rules.material.texture);\\n\\n    //                 // //задаём параметры, чтобы можно было отрисовать изображение любого размера\\n    //                 // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_S, this.gl.CLAMP_TO_EDGE);\\n    //                 // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_WRAP_T, this.gl.CLAMP_TO_EDGE);\\n    //                 // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MIN_FILTER, this.gl.NEAREST);\\n    //                 // this.gl.texParameteri(this.gl.TEXTURE_2D, this.gl.TEXTURE_MAG_FILTER, this.gl.NEAREST);\\n\\n    //                     // const num = 2;              // каждая координата состоит из 2 значений\\n    //                     // const type = this.gl.FLOAT; // данные в буфере имеют тип 32 bit float\\n    //                     // const normalize = false;    // не нормализуем\\n    //                     // const stride = 0;           // сколько байт между одним набором данных и следующим\\n    //                     // const offset = 0;           // стартовая позиция в байтах внутри набора данных\\n    //                 //this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers[key]);\\n    //                 // this.gl.vertexAttribPointer(this.aData[key], num, type, normalize, stride, offset);\\n    //                 // this.gl.enableVertexAttribArray(this.aData[key]);\\n\\n    //                 // // загружаем изображение в текстуру\\n    //                  //this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, this.gl.RGBA, this.gl.UNSIGNED_BYTE, rules.material.data.map);\\n    //             break;\\n    //         };\\n    //     }\\n    // }\\n    getAtrLocations(gl,program,atrNames){\\n        let atrLoc = {};\\n        for (let i=0;i<atrNames.length;i++){\\n            atrLoc[atrNames[i]] = gl.getAttribLocation(program,atrNames[i]);\\n        }\\n        this.aData = atrLoc;\\n    }\\n    getUnifLocations(gl,program,unifNames){\\n        let unifLoc = {};\\n        for (let i=0;i<unifNames.length;i++){\\n            unifLoc[unifNames[i]] = gl.getUniformLocation(program,unifNames[i]);\\n        }\\n        this.uData = unifLoc;\\n    }\\n}\\n\\n// CONCATENATED MODULE: ./src/program/WebGlPrograms.js\\n\\n\\nclass WebGlPrograms_WebGlPrograms {\\n    constructor(gl){\\n        this.gl = gl;\\n    }\\n    compilePr(shadersCode){\\n        let atributes = [];\\n        let uniforms = [];\\n        let program = this.createProgram(shadersCode.vertex,shadersCode.fragment);\\n\\n        const numAttribs = this.gl.getProgramParameter(program, this.gl.ACTIVE_ATTRIBUTES);\\n            for (let i = 0; i < numAttribs; i++) {\\n                atributes[i]=this.gl.getActiveAttrib(program, i).name;\\n            }\\n        const numUniforms = this.gl.getProgramParameter(program, this.gl.ACTIVE_UNIFORMS);\\n            for (let i = 0; i < numUniforms; ++i) {\\n                uniforms[i]=this.gl.getActiveUniform(program, i).name;\\n            }\\n\\n        return  new ProgramRules(this.gl,program,atributes,uniforms);\\n    }\\n    createShaders(type,source){\\n        let shader = this.gl.createShader(type); \\n        this.gl.shaderSource(shader, source);      \\n        this.gl.compileShader(shader);            \\n        if (this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)){                        \\n            return shader;\\n        }\\n        else {\\n            console.log(this.gl.getShaderInfoLog(shader));\\n            this.gl.deleteShader(shader);\\n        }\\n    }\\n    createProgram(vertex,fragment){\\n\\n        let program = this.gl.createProgram();\\n        this.gl.attachShader(program, this.createShaders(this.gl.VERTEX_SHADER,vertex));\\n        this.gl.attachShader(program, this.createShaders(this.gl.FRAGMENT_SHADER,fragment));\\n        this.gl.linkProgram(program);\\n        if (this.gl.getProgramParameter(program, this.gl.LINK_STATUS)){\\n          return program; \\n        }\\n        else {\\n            console.log(this.gl.getProgramInfoLog(program));\\n            this.gl.deleteProgram(program);\\n        }\\n    }\\n}\\n\\n\\n\\n/*\\n\\n        if ((camera === undefined)&(mesh.material === undefined)){\\n            vertex = `\\n                attribute vec3 a_position;\\n\\n                uniform mat4 modelMatrix;\\n\\n                varying vec4 und_color;\\n\\n                void main() {\\n                    gl_Position = modelMatrix * vec4(a_position.xyz,1.0); \\n                    und_color = gl_Position * 0.5 + 0.5;\\n                }\\n            `;\\n            fragment = `\\n                precision mediump float;\\n\\n                varying vec4 und_color;\\n\\n                void main() {\\n                    gl_FragColor = und_color;\\n                }\\n            `;\\n            atrNames = ['a_position'];\\n            uniformVarNames =['modelMatrix'];\\n        }\\n        else if ((camera === undefined)&(mesh.material !== undefined)){\\n            vertex = `\\n                attribute vec3 a_position;\\n                attribute vec4 a_color;\\n        \\n                uniform mat4 modelMatrix;\\n        \\n                varying vec4 v_color;\\n        \\n                void main() {\\n                    gl_Position = modelMatrix * vec4(a_position.xyz,1.0);\\n                    v_color = a_color;\\n                }\\n            `;\\n            fragment = mesh.material.getFragmentCode();\\n            atrNames = ['a_position','a_color'];\\n            uniformVarNames =['modelMatrix'];\\n        }\\n        else if ((camera !== undefined)&(mesh.material === undefined)){\\n            vertex = `\\n                attribute vec3 a_position;\\n\\n                uniform mat4 modelMatrix;\\n                uniform mat4 viewMatrix;\\n                uniform mat4 projMatrix;\\n\\n                varying vec4 und_color;\\n\\n                void main() {\\n                    gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0);\\n                    und_color = gl_Position * 0.5 + 0.5;\\n                }\\n            `;\\n            fragment = `\\n                precision mediump float;\\n\\n                varying vec4 und_color;\\n\\n                void main() {\\n                    gl_FragColor = und_color;\\n                }\\n            `;\\n            atrNames = ['a_position'];\\n            uniformVarNames = ['modelMatrix','viewMatrix','projMatrix'];\\n        }\\n        else if ((camera !== undefined)&(mesh.material !== undefined)){\\n            vertex = `\\n                attribute vec3 a_position;\\n                attribute vec4 a_color;\\n\\n                uniform mat4 modelMatrix;\\n                uniform mat4 viewMatrix;\\n                uniform mat4 projMatrix;\\n\\n                varying vec4 v_color;\\n\\n                void main() {\\n                    gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); \\n                    v_color = a_color;\\n                }\\n            `;\\n            fragment = mesh.material.getFragmentCode();\\n            atrNames = ['a_position','a_color'];\\n            uniformVarNames = ['modelMatrix','viewMatrix','projMatrix'];\\n        }\\n*/\\n// CONCATENATED MODULE: ./src/material/CoreMaterial.js\\n\\n\\nclass CoreMaterial_CoreMaterial {\\n    constructor (data){\\n        this.type = 'material';\\n        this.data = data;\\n        this.struct = {\\n            color: (this.data.color!==undefined),\\n            map: (this.data.map!==undefined),\\n        }\\n    }\\n    createShadersCode(code){\\n        //let data = Object.entries(this.data);\\n        if (!(this.struct.color||this.struct.map)){\\n                console.log('Add material! Color or/and map like {color:[0.0,0.0,0.0,1.0]}');\\n          } else if (this.struct.color & !this.struct.map){\\n                this.shadersCode = code.color;\\n          } else if (!this.struct.color & this.struct.map){\\n                this.shadersCode = code.map;\\n          } else if (this.struct.color & this.struct.map){\\n                this.shadersCode = code.mapAndColor;\\n          }\\n    }\\n    getProgram(gl){ \\n        return new WebGlPrograms_WebGlPrograms(gl).compilePr(this.shadersCode);\\n    }\\n    makeWebGlDependenseFcn(gl){\\n        if (this.struct.map) this.createTexture(gl);\\n    }\\n    createTexture(gl){\\n        this.texture = gl.createTexture();\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/material/BasicMaterial.js\\n\\n\\nconst shadersBasicMaterial = {\\n    color:{\\n        vertex: `\\n        attribute vec3 a_position;\\n    \\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n    \\n        uniform vec4 v_color;\\n    \\n        void main() {\\n            gl_FragColor = v_color;\\n        }\\n    `,\\n    },\\n    map:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec2 aTextureCoord;\\n    \\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n    \\n        varying highp vec2 vTextureCoord;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n            vTextureCoord = aTextureCoord;\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n    \\n        varying highp vec2 vTextureCoord;\\n        uniform sampler2D uSampler;\\n    \\n        void main() {\\n            gl_FragColor = texture2D(uSampler, vTextureCoord);\\n        }\\n    `,\\n    },\\n    mapAndColor:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec2 aTextureCoord;\\n    \\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n    \\n        varying highp vec2 vTextureCoord;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n            vTextureCoord = aTextureCoord;\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n\\n        uniform sampler2D uSampler;\\n        uniform vec4 v_color;\\n\\n        varying highp vec2 vTextureCoord;\\n\\n    \\n        void main() {\\n            highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\\n            gl_FragColor = texelColor * v_color;\\n        }\\n    `,\\n    }\\n};\\n\\nclass BasicMaterial_BasicMaterial extends CoreMaterial_CoreMaterial{\\n    constructor(data){\\n        super(data);\\n        this.createShadersCode(shadersBasicMaterial);\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/camera/Camera.js\\n\\n\\n\\nclass Camera_Camera{\\n    constructor(){\\n        this.position = new Coordinates3D();\\n        this.rotation = new Coordinates3D(); \\n        this.scale = new Coordinates3D(1,1,1);\\n        this.ortographicSett = {\\n            right: 0,\\n            left: 0,\\n            top: 0, \\n            bottom: 0, \\n            far: 0,\\n            near: 0,\\n        };\\n        this.perspectiveSett = {\\n            zNear: 0.5,\\n            zFar: 0,\\n            fov: 60,\\n            aspect:0,\\n        };\\n    }\\n    updateCameraMtrx(){\\n        this.viewMatrix = new Matrix_Matrix().invertModelMatrix(this.position,this.scale,this.rotation);\\n        this.ortographicMatrix = new Matrix_Matrix().ortographic(this.ortographicSett);\\n        this.perspectiveMatrix = new Matrix_Matrix().perspective(this.perspectiveSett);\\n        this.projMatrix = this.perspectiveMatrix;\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/Mesh.js\\n\\n\\n\\n\\nclass Mesh_Mesh {\\n    constructor(geometry,material){\\n        this.type = 'mesh';\\n        this.position = new Coordinates3D();\\n        this.rotation = new Coordinates3D(); \\n        this.scale = new Coordinates3D(1,1,1);\\n        this.dafaultMaterial = new BasicMaterial_BasicMaterial ({color: [1.0, 1.0, 1.0, 1.0]});\\n        this.createDisplayRules(geometry.getGeometry(),material);\\n        \\n    }\\n    createProgramRules(gl){\\n        for (let k=0;k<this.displayRules.length;k++){\\n            this.displayRules[k].material.progRules = this.displayRules[k].material.getProgram(gl);\\n        }\\n    }\\n    doProgram(gl,camera,light){\\n        for (let k=0;k<this.displayRules.length;k++){\\n            gl.useProgram(this.displayRules[k].material.progRules.program);\\n            this.displayRules[k].material.progRules.setUniform(\\n                this.modelMatrix,\\n                this.invTranspModelMatrix,\\n                this.displayRules[k],\\n                camera,\\n                light);\\n                this.displayRules[k].material.progRules.setAttribute(this.displayRules[k]);\\n            gl.drawArrays(gl.TRIANGLES, 0, this.displayRules[k].geometry.info.numVertex);\\n        }\\n        this.doneSendAttribute  = false;\\n    }\\n    createDisplayRules(geometry,material){\\n        let rules = [];\\n        let newMaterial = this.createMaterial(geometry,material);\\n        for (let i=0;i<geometry.parts.length;i++){\\n            if (this.monoChrome){\\n                rules[i] = {\\n                    material: newMaterial,\\n                    geometry: geometry.parts[i]\\n                };\\n            } else {\\n                rules[i] = {\\n                    material: newMaterial[i],\\n                    geometry: geometry.parts[i]\\n                };\\n            }\\n        }\\n        this.displayRules = rules;\\n    }\\n    createMaterial(geometry,material){\\n        let newMaterial = [];\\n        let isMaterialArray = Array.isArray(material);\\n        this.monoChrome = !isMaterialArray;\\n        if (isMaterialArray){\\n            for (let i=0;i<geometry.parts.length;i++){\\n                if(material[i]!==undefined){\\n                    newMaterial[i]=material[i];\\n                } else {\\n                    newMaterial[i] = this.dafaultMaterial;\\n                } \\n            }\\n        } else newMaterial = material;\\n\\n        return newMaterial;\\n    }\\n    updateMeshMatrix(){ \\n        this.modelMatrix = new Matrix_Matrix().multiplyToModel(this.position,this.scale,this.rotation);\\n        this.invTranspModelMatrix = new Matrix_Matrix().invert(new Matrix_Matrix().transpose(this.modelMatrix));\\n    }\\n}\\n\\n\\n\\n\\n// CONCATENATED MODULE: ./src/geometry/CoreGeometry.js\\n\\nclass CoreGeometry {\\n    constructor(){\\n        this.partsGeometry = [];\\n    }\\n    createGeometry (type,cordVertex,cordMap,cordNormals){\\n        return {\\n            type: type,\\n            cord:{\\n                vertex: cordVertex,\\n                map: cordMap,\\n                normals: cordNormals\\n            },\\n            info:{\\n                numVertex: cordVertex.length/3,\\n            }\\n        };\\n    }\\n    createSolidGeometry(){\\n        let vertexCord = [];\\n        let mapCord = [];\\n        let normals = [];\\n        let numVertex = 0;\\n        for (let i=0;i<this.partsGeometry.length;i++){\\n            vertexCord = vertexCord.concat(this.partsGeometry[i].cord.vertex);\\n            mapCord = mapCord.concat(this.partsGeometry[i].cord.map);\\n            normals = mapCord.concat(this.partsGeometry[i].cord.normals);\\n            numVertex += this.partsGeometry[i].info.numVertex;\\n        } \\n        this.solidGeometry = this.createGeometry('solid',vertexCord,mapCord,normals,numVertex);\\n        this.solidGeometry.info.numParts = this.partsGeometry.length;\\n        return this.solidGeometry;\\n    }\\n    getGeometry(){\\n        return {\\n            parts: this.createVertex(),\\n        };\\n    }\\n    createVertex(){}\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/geometry/RectangularGeometry.js\\n\\n\\n\\n\\nclass RectangularGeometry_RectangularGeometry {\\n    constructor(w,h,x,y,z){\\n      this.start = new Coordinates3D(x,y,z);\\n      this.w = w;\\n      this.h = h;\\n      this.createVertex();\\n    }\\n    createVertex(){\\n        let x0 = this.start.x;\\n        let x1 = x0+ this.w;\\n        let y0 = this.start.y;\\n        let y1 = y0+this.h; \\n        let z0 = this.start.z;\\n\\n        let vertex =  [\\n            x0,y0,z0,\\n            x1,y0,z0,\\n            x0,y1,z0,\\n      \\n            x0,y1,z0,\\n            x1,y0,z0,\\n            x1,y1,z0,\\n        ];\\n        this.cord = vertex;\\n        this.numVertex = vertex.length / 3;\\n        //this.offsetBytes = vertex.length * 4;\\n        this.numFaces = 1;\\n    }\\n\\n}\\n\\n\\n\\n// CONCATENATED MODULE: ./src/Scene.js\\n\\n\\nclass Scene_Scene {\\n    constructor(){\\n        this.meshs = [];\\n        this.lights = [];\\n        this.background = [0.0, 0.0, 0.0, 1.0];\\n        this.needUpdate = false;\\n    }\\n    createLightRules (){\\n\\n        let rules = {};\\n        for (let i=0;i<this.lights.length;i++){\\n            if (this.lights[i].typeLight=='ambient'){\\n                rules.ambient = this.lights[i].createDataToWebgl();\\n            }else {\\n                rules.source = this.lights[i].createDataToWebgl();\\n            }\\n        }\\n        if (rules['ambient'] == undefined){\\n            rules['ambient'] = {\\n                color: [0.0,0.0,0.0],\\n                intensity: 0.0,\\n            };\\n        } \\n        if (rules['source'] == undefined){\\n            rules['source']= {\\n                color: [0.0,0.0,0.0],\\n                intensity: 0,\\n                positionLight: new Coordinates3D(),\\n                shiniess: 0.0,\\n                specularColor: [0.0,0.0,0.0],\\n                specularInt: 0.0,\\n                k_vertex: 1.0,\\n            };\\n        }\\n        this.lightRules = rules;\\n        //console.log(rules);\\n    }\\n    add(object){\\n        if (object.type == 'mesh'){\\n            this.meshs = this.meshs.concat(object);\\n        } else if (object.type == 'light') {\\n            this.lights = this.lights.concat(object);\\n        }\\n        this.needUpdate = true;\\n    }\\n    update(gl){\\n        if (this.needUpdate){ \\n            for (let i=0;i<this.meshs.length;i++){\\n                for (let k=0;k<this.meshs[i].displayRules.length;k++){\\n                    this.meshs[i].createProgramRules(gl);\\n                    this.meshs[i].displayRules[k].material.makeWebGlDependenseFcn(gl);\\n                }\\n                console.log(this.meshs[i]);\\n            }\\n            if (this.lights.length>0){\\n                this.createLightRules();\\n            }\\n            console.log(this.lightRules);\\n            this.needUpdate = false;\\n        }\\n        for (let i=0;i<this.meshs.length;i++){\\n            this.meshs[i].updateMeshMatrix();\\n        }\\n    }\\n    useProgram(gl,camera){\\n        for (let i=0;i<this.meshs.length;i++){\\n            this.meshs[i].doProgram(gl,camera,this.lightRules);\\n        }\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/geometry/TriangleGeometry.js\\n\\n\\n\\nclass TriangleGeometry_TriangleGeometry {\\n    constructor(w,h,x,y,z){\\n      this.start = new Coordinates3D(x,y,z);\\n      \\n      this.w = w;\\n      this.h = h;\\n      this.createVertex();\\n    }\\n    createVertex(){\\n        let x0 = this.start.x;\\n        let y0 = this.start.y;\\n        let z0 = this.start.z;\\n\\n        let x1 = x0 + this.w;\\n        let x2 = x0 - this.w;\\n        let y1 = y0 + this.h; \\n\\n        let vertex =  [\\n            x0,y0,z0,\\n            x2,y1,z0,\\n            x1,y1,z0\\n        ];\\n        this.cord = vertex;\\n        this.numVertex = vertex.length / 3;\\n        this.numPoints = 3;\\n        this.offsetBytes = vertex.length * 4;\\n        this.numEdges = 1;\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/WebGlRender.js\\n\\nclass WebGlRender {\\n    constructor (canvas){\\n        this.canvas = canvas;\\n        this.getContext();\\n    }\\n    render(scene,camera){\\n        this.clearScreen(scene.background);\\n        this.update(scene,camera);\\n        this.draw(scene,camera);\\n    }\\n    update(scene,camera){\\n        scene.update(this.gl);\\n        camera.updateCameraMtrx();\\n    }\\n    draw(scene,camera){\\n        scene.useProgram(this.gl,camera);\\n    }\\n    clearScreen(background){\\n        this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);\\n        this.gl.clearColor(background[0],\\n                           background[1],\\n                           background[2],\\n                           background[3]);  // Clear to black, fully opaque //(0.0, 0.0, 0.0, 1.0)\\n        this.gl.clearDepth(1.0);                 // Clear everything\\n        this.gl.enable(this.gl.DEPTH_TEST);           // Enable depth testing\\n        //this.gl.enable(this.gl.CULL_FACE);\\n        this.gl.depthFunc(this.gl.LEQUAL);            // Near things obscure far things\\n        this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);\\n    }\\n    getContext(){\\n        this.gl = this.canvas.getContext('webgl');\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/geometry/BoxGeometry.js\\n\\n\\n\\n\\nclass BoxGeometry_BoxGeometry extends CoreGeometry{\\n    constructor (w,h,d,x,y,z){\\n        super();\\n        this.w = w;\\n        this.h = h;\\n        this.d = d;\\n        this.start = new Coordinates3D(x,y,z);\\n        //this.createVertex();\\n    }\\n    createVertex(){\\n        let vertex = [];\\n        let frontRect = new RectangularGeometry_RectangularGeometry(this.w,this.h,this.start.x,this.start.y,this.d/2);\\n        let backRect = new RectangularGeometry_RectangularGeometry(this.w,this.h,this.start.x,this.start.y,-(this.d/2));\\n\\n//--------------- TOP -----------------------------\\n        let topX0 = frontRect.cord[0];\\n        let topY0 = frontRect.cord[1];\\n        let topZ0 = frontRect.cord[2];\\n\\n        let topX1 = frontRect.cord[3];\\n        let topY1 = frontRect.cord[4];\\n        let topZ1 = frontRect.cord[5];  \\n\\n        let topX2 = backRect.cord[0];\\n        let topY2 = backRect.cord[1];\\n        let topZ2 = backRect.cord[2];\\n//----------------------------------------------------\\n        let topX3 = backRect.cord[3];\\n        let topY3 = backRect.cord[4];\\n        let topZ3 = backRect.cord[5];\\n\\n        let topVertex =  [\\n            topX0,topY0,topZ0,\\n            topX1,topY1,topZ1,\\n            topX2,topY2,topZ2,\\n      \\n            topX2,topY2,topZ2,\\n            topX1,topY1,topZ1,\\n            topX3,topY3,topZ3,\\n        ];\\n//--------------- Bottom -----------------------------\\n        let bottomX0 = frontRect.cord[9];\\n        let bottomY0 = frontRect.cord[10];\\n        let bottomZ0 = frontRect.cord[11];\\n\\n        let bottomX1 = frontRect.cord[15];\\n        let bottomY1 = frontRect.cord[16];\\n        let bottomZ1 = frontRect.cord[17];  \\n\\n        let bottomX2 = backRect.cord[9];\\n        let bottomY2 = backRect.cord[10];\\n        let bottomZ2 = backRect.cord[11];\\n//----------------------------------------------------\\n        let bottomX3 = backRect.cord[15];\\n        let bottomY3 = backRect.cord[16];\\n        let bottomZ3 = backRect.cord[17];\\n\\n        let bottomVertex =  [\\n            bottomX0,bottomY0,bottomZ0,\\n            bottomX1,bottomY1,bottomZ1,\\n            bottomX2,bottomY2,bottomZ2,\\n\\n            bottomX2,bottomY2,bottomZ2,\\n            bottomX1,bottomY1,bottomZ1,\\n            bottomX3,bottomY3,bottomZ3,\\n        ];\\n        let leftVertex =  [\\n            topX0,topY0,topZ0,\\n            topX2,topY2,topZ2,\\n            bottomX0,bottomY0,bottomZ0,\\n\\n            bottomX0,bottomY0,bottomZ0,\\n            topX2,topY2,topZ2,\\n            bottomX2,bottomY2,bottomZ2,\\n        ];\\n        let rightVertex =  [\\n            topX1,topY1,topZ1,\\n            topX3,topY3,topZ3,\\n            bottomX1,bottomY1,bottomZ1,\\n\\n            bottomX1,bottomY1,bottomZ1,\\n            topX3,topY3,topZ3,\\n            bottomX3,bottomY3,bottomZ3,\\n        ];\\n\\n        const mapCord2D = [\\n            0.0,  0.0,\\n            1.0,  0.0,\\n            0.0,  1.0,\\n            0.0,  1.0,\\n            1.0,  0.0,\\n            1.0,  1.0 \\n        ];\\n        const frontNormals = [\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n        ];\\n        const backNormals = [\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n        ];\\n        const topNormals = [\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n        ];\\n        const bottomNormals = [\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n        ];\\n        const leftNormals = [\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n        ];\\n        const rightNormals = [\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n        ];\\n\\n        this.partsGeometry = [\\n            this.createGeometry('part',frontRect.cord,mapCord2D,frontNormals),\\n            this.createGeometry('part',backRect.cord,mapCord2D,backNormals),\\n            this.createGeometry('part',topVertex,mapCord2D,topNormals),\\n            this.createGeometry('part',bottomVertex,mapCord2D,bottomNormals),\\n            this.createGeometry('part',leftVertex,mapCord2D,leftNormals),\\n            this.createGeometry('part',rightVertex,mapCord2D,rightNormals),\\n        ];\\n\\n        //vertex = vertex.concat(frontRect.cord,backRect.cord,topVertex,bottomVertex,leftVertex,rightVertex);\\n        return this.partsGeometry;\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/material/Material.js\\n\\n\\nclass Material_Material {\\n    constructor(type){\\n        this.type = type;\\n        this.needUpdate = true;\\n    }\\n    getProgram(gl){\\n        return new WebGlPrograms_WebGlPrograms(gl).compilePr(this.vertex,this.fragment);\\n    }\\n    update(){}\\n    makeWebGlDependenseFcn(){}\\n}\\n\\n// CONCATENATED MODULE: ./src/material/TextureMaterial.js\\n\\n\\nconst vertexTextureMaterial = `\\n    attribute vec3 a_position;\\n    attribute vec2 aTextureCoord;\\n\\n    uniform mat4 modelMatrix;\\n    uniform mat4 viewMatrix;\\n    uniform mat4 projMatrix;\\n\\n    varying highp vec2 vTextureCoord;\\n\\n    void main() {\\n        gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n        vTextureCoord = aTextureCoord;\\n    }\\n`;\\nconst fragmentTextureMaterial = `\\n    precision mediump float;\\n\\n    varying highp vec2 vTextureCoord;\\n    uniform sampler2D uSampler;\\n\\n    void main() {\\n        gl_FragColor = texture2D(uSampler, vTextureCoord);\\n    }\\n`;\\n\\nclass TextureMaterial_TextureMaterial extends Material_Material {\\n    constructor(image){\\n        super('texture2D');\\n        this.image = image;\\n        this.vertex = vertexTextureMaterial;\\n        this.fragment = fragmentTextureMaterial;\\n    }\\n    makeWebGlDependenseFcn(gl){\\n        this.createTexture(gl);\\n    }\\n    createTexture(gl){\\n        this.texture = gl.createTexture();\\n    }\\n    update(dataGeom){\\n        let arr = [];\\n        let cord = [\\n            0.0,  0.0,\\n            1.0,  0.0,\\n            0.0,  1.0,\\n            0.0,  1.0,\\n            1.0,  0.0,\\n            1.0,  1.0 ];\\n        for (let i = 0; i<dataGeom.numEdges;i++){\\n            arr = arr.concat(cord);\\n        } \\n        this.textureCord = arr;\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/material/GradientMaterial.js\\n\\n\\nconst vertexGradientMaterial = `\\n    attribute vec3 a_position;\\n\\n    uniform mat4 modelMatrix;\\n    uniform mat4 viewMatrix;\\n    uniform mat4 projMatrix;\\n\\n    varying vec4 v_color;\\n\\n    void main() {\\n        gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n        v_color = gl_Position * 0.5 + 0.5;\\n    }\\n`;\\nconst fragmentGradientMaterial = `\\n    precision mediump float;\\n\\n    varying vec4 v_color;\\n\\n    void main() {\\n        gl_FragColor = v_color;\\n    }\\n`;\\n\\nclass GradientMaterial_GradientMaterial extends Material_Material{\\n    constructor(){\\n        super('gradient');\\n        this.vertex = vertexGradientMaterial;\\n        this.fragment = fragmentGradientMaterial;\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/material/MonochromeColor.js\\n\\n\\nconst vertexMonoColorMaterial = `\\n    attribute vec3 a_position;\\n\\n    uniform mat4 modelMatrix;\\n    uniform mat4 viewMatrix;\\n    uniform mat4 projMatrix;\\n\\n    void main() {\\n        gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n    }\\n`;\\nconst fragmentMonoColorMaterial = `\\n    precision mediump float;\\n\\n    uniform vec4 color;\\n\\n    void main() {\\n        gl_FragColor = color;\\n    }\\n`;\\n\\nclass MonochromeColor_MonochromeColor extends Material_Material {\\n    constructor (color){\\n        super('monoColor');\\n        this.color = color;\\n        this.vertex = vertexMonoColorMaterial;\\n        this.fragment = fragmentMonoColorMaterial;\\n    }\\n\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/material/PhongMaterial.js\\n\\n\\nconst shadersPhongMaterial = {\\n    color:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec3 a_normal;\\n\\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n\\n        uniform mat4 invTranspModelMatrix;\\n\\n        varying vec3 world_Vertex;\\n        varying vec3 world_Normal;\\n\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0);\\n\\n            world_Vertex = mat3(invTranspModelMatrix) * a_position; \\n            world_Normal = mat3(invTranspModelMatrix) * a_normal; \\n        }\\n    `,\\n        fragment: `\\n        precision highp float;\\n    \\n        uniform vec4 v_color;\\n\\n        uniform float k_vertex;\\n\\n        uniform float u_ambIntensity;\\n        uniform vec3 u_ambLightColor;\\n\\n        uniform float u_intensity;\\n        uniform vec3 u_lightColor;\\n\\n        uniform float u_shininess;\\n\\n        uniform vec3 u_specularColor;\\n        uniform float u_specularInt;\\n\\n        uniform vec3 u_lightWorldPosition;\\n        uniform vec3 u_viewWorldPosition;\\n\\n        varying vec3 world_Vertex;\\n        varying vec3 world_Normal;\\n\\n        vec3 ambient_color;\\n        vec3 diffuse_color;\\n        vec3 specular_color;\\n\\n        vec3 color;\\n\\n        void main() {\\n            ambient_color = u_ambLightColor * u_ambIntensity; // фоновое освещение 1 на всю сцену\\n\\n                vec3 normal = normalize(world_Normal);\\n                float k = clamp(k_vertex, 0.0, 1.0);\\n\\n                vec3 to_light = u_lightWorldPosition - k * world_Vertex;\\n                to_light = normalize(to_light);\\n\\n                float cos_angle = dot(normal,to_light); \\n                cos_angle = clamp(cos_angle, 0.0, 1.0);\\n\\n            diffuse_color = cos_angle * u_lightColor * u_intensity;  \\n\\n                vec3 to_View = u_viewWorldPosition -  k * world_Vertex;\\n                to_View = normalize(to_View);\\n\\n                vec3 halfVector = normalize(to_View + to_light);\\n\\n            specular_color = (pow(dot(normal, halfVector), u_shininess) * u_specularColor) * u_specularInt;\\n                    \\n            color =  ambient_color; \\n            color += v_color.rgb * diffuse_color;\\n            color += specular_color;\\n\\n            gl_FragColor = vec4(color,v_color.a);//vec3(specularInt,specularInt,specularInt)\\n        }\\n    `,\\n    },\\n    map:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec2 aTextureCoord;\\n        attribute vec3 a_normal;\\n    \\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n\\n        uniform mat4 invTranspModelMatrix;\\n    \\n        varying highp vec2 vTextureCoord;\\n\\n        varying vec3 world_Vertex;\\n        varying vec3 world_Normal;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0);\\n            vTextureCoord = aTextureCoord;\\n            world_Vertex = mat3(invTranspModelMatrix) * a_position; \\n            world_Normal = mat3(invTranspModelMatrix) * a_normal;\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n\\n        uniform sampler2D uSampler;\\n\\n        varying highp vec2 vTextureCoord;\\n\\n        uniform float k_vertex;\\n\\n        uniform float u_ambIntensity;\\n        uniform vec3 u_ambLightColor;\\n\\n        uniform float u_intensity;\\n        uniform vec3 u_lightColor;\\n\\n        uniform float u_shininess;\\n\\n        uniform vec3 u_specularColor;\\n        uniform float u_specularInt;\\n\\n        uniform vec3 u_lightWorldPosition;\\n        uniform vec3 u_viewWorldPosition;\\n\\n        varying vec3 world_Vertex;\\n        varying vec3 world_Normal;\\n\\n        vec3 ambient_color;\\n        vec3 diffuse_color;\\n        vec3 specular_color;\\n\\n        vec3 color;\\n    \\n        void main() {\\n\\n            ambient_color = u_ambLightColor * u_ambIntensity; // фоновое освещение 1 на всю сцену\\n\\n                vec3 normal = normalize(world_Normal);\\n                float k = clamp(k_vertex, 0.0, 1.0);\\n\\n                vec3 to_light = u_lightWorldPosition - k * world_Vertex;\\n                to_light = normalize(to_light);\\n\\n                float cos_angle = dot(normal,to_light); \\n                cos_angle = clamp(cos_angle, 0.0, 1.0);\\n\\n            diffuse_color = cos_angle * u_lightColor * u_intensity;  \\n\\n                vec3 to_View = u_viewWorldPosition -  k * world_Vertex;\\n                to_View = normalize(to_View);\\n\\n                vec3 halfVector = normalize(to_View + to_light);\\n\\n            specular_color = (pow(dot(normal, halfVector), u_shininess) * u_specularColor) * u_specularInt;\\n\\n            highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\\n                    \\n            color = ambient_color; \\n            color += texelColor.rgb * diffuse_color; // \\n            color += specular_color;\\n\\n            gl_FragColor = vec4(color, texelColor.a);\\n        }\\n    `,\\n    },\\n    mapAndColor:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec2 aTextureCoord;\\n        attribute vec3 a_normal;\\n    \\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n\\n        uniform mat4 invTranspModelMatrix;\\n    \\n        varying highp vec2 vTextureCoord;\\n\\n        varying vec3 world_Vertex;\\n        varying vec3 world_Normal;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0);\\n            vTextureCoord = aTextureCoord;\\n            world_Vertex = mat3(invTranspModelMatrix) * a_position; \\n            world_Normal = mat3(invTranspModelMatrix) * a_normal;\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n\\n        uniform vec4 v_color;\\n\\n        uniform sampler2D uSampler;\\n\\n        varying highp vec2 vTextureCoord;\\n\\n        uniform float k_vertex;\\n\\n        uniform float u_ambIntensity;\\n        uniform vec3 u_ambLightColor;\\n\\n        uniform float u_intensity;\\n        uniform vec3 u_lightColor;\\n\\n        uniform float u_shininess;\\n\\n        uniform vec3 u_specularColor;\\n        uniform float u_specularInt;\\n\\n        uniform vec3 u_lightWorldPosition;\\n        uniform vec3 u_viewWorldPosition;\\n\\n        varying vec3 world_Vertex;\\n        varying vec3 world_Normal;\\n\\n        vec3 ambient_color;\\n        vec3 diffuse_color;\\n        vec3 specular_color;\\n\\n        vec3 color;\\n    \\n        void main() {\\n\\n            ambient_color = u_ambLightColor * u_ambIntensity; // фоновое освещение 1 на всю сцену\\n\\n                vec3 normal = normalize(world_Normal);\\n                float k = clamp(k_vertex, 0.0, 1.0);\\n\\n                vec3 to_light = u_lightWorldPosition - k * world_Vertex;\\n                to_light = normalize(to_light);\\n\\n                float cos_angle = dot(normal,to_light); \\n                cos_angle = clamp(cos_angle, 0.0, 1.0);\\n\\n            diffuse_color = cos_angle * u_lightColor * u_intensity;  \\n\\n                vec3 to_View = u_viewWorldPosition -  k * world_Vertex;\\n                to_View = normalize(to_View);\\n\\n                vec3 halfVector = normalize(to_View + to_light);\\n\\n            specular_color = (pow(dot(normal, halfVector), u_shininess) * u_specularColor) * u_specularInt;\\n\\n            highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\\n            texelColor *= v_color;\\n            color = ambient_color; \\n            color += texelColor.rgb * diffuse_color; // \\n            color += specular_color;\\n\\n            gl_FragColor = vec4(color, texelColor.a);\\n        }\\n    `,\\n    },\\n};\\n\\nclass PhongMaterial_PhongMaterial extends CoreMaterial_CoreMaterial{\\n    constructor(data){\\n        super(data);\\n        this.createShadersCode(shadersPhongMaterial);\\n    }\\n}\\n\\n\\n/*\\n // программа есть не один источник света \\n\\n            // light_color = vec3(0);\\n            // для каждого источника света light_color += \\n                //cos_angle[текущего источника] * u_lightColor[текущего источника] * u_intensity[текущего источника];\\n            // specular = СУММ(specular_light[текущего источника]);\\n            //rslt = ambient_color =(u_lightColor * u_intensity);\\n            // rslt += v_color.rgb * light_color;\\n            // rslt += specular;\\n\\n\\n\\n    // specular вариант вычисления \\n                    reflection = 2.0 * cos_angle * normal - to_light;\\n                reflection = normalize(reflection);\\n                \\n                to_camera = -1.0 * v_Vertex;\\n                to_camera = normalize(to_camera);\\n\\n                cos_angle = dot(reflection, to_camera);\\n                cos_angle = clamp(cos_angle, 0.0, 1.0);\\n                cos_angle = pow(cos_angle, u_shininess);\\n\\n                if (cos_angle > 0.0) {\\n                    specular_color = u_lightColor * cos_angle;\\n                    diffuse_color = diffuse_color * (1.0 - cos_angle);\\n                  } else {\\n                    specular_color = vec3(0.0, 0.0, 0.0);\\n                  }\\n*/\\n\\n/*\\nconst shadersPhongMaterial = {\\n    color:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec3 a_normal;\\n    \\n        uniform vec3 u_lightWorldPosition;\\n        uniform vec3 u_viewWorldPosition;\\n        uniform mat4 modelMatrix;\\n        uniform mat4 invTranspModelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n\\n        varying vec3 v_normal;\\n        varying vec3 v_surfaceToLight;\\n        varying vec3 v_surfaceToView;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); \\n\\n            v_normal =  mat3(invTranspModelMatrix) * a_normal;\\n            vec3 surfaceWorldPosition = mat3(modelMatrix) * a_position.xyz;\\n            v_surfaceToLight = u_lightWorldPosition - surfaceWorldPosition;\\n            v_surfaceToView = u_viewWorldPosition - surfaceWorldPosition;\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n    \\n        uniform vec4 v_color;\\n        uniform vec3 u_reverseLightDirection;\\n        uniform float u_shininess;\\n\\n        uniform vec3 u_lightColor;\\n        uniform vec3 u_specularColor;\\n\\n        varying vec3 v_normal;\\n        varying vec3 v_surfaceToLight;\\n        varying vec3 v_surfaceToView;\\n\\n        void main() {\\n            vec3 normal = normalize(v_normal);\\n            vec3 surfaceToLightDirection = normalize(v_surfaceToLight);\\n            vec3 surfaceToViewDirection = normalize(v_surfaceToView);\\n            vec3 halfVector = normalize(surfaceToLightDirection + surfaceToViewDirection);\\n\\n            //float light = dot(normal, u_reverseLightDirection);\\n            float light = dot(normal, surfaceToLightDirection);\\n            float specular = 0.0;\\n            \\n            if (light > 0.0) {\\n              specular = pow(dot(normal, halfVector), u_shininess);\\n            }\\n\\n            gl_FragColor = v_color;\\n            gl_FragColor.rgb *=  light * u_lightColor;\\n            gl_FragColor.rgb += specular * u_specularColor;\\n        }\\n    `,\\n    },\\n    map:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec2 aTextureCoord;\\n        attribute vec3 aVertexNormal;\\n    \\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n        uniform mat4 uNormalMatrix;\\n    \\n        varying highp vec2 vTextureCoord;\\n        varying highp vec3 vLighting;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n            vTextureCoord = aTextureCoord;\\n            highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\\n            highp vec3 directionalLightColor = vec3(1, 1, 1);\\n            highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\\n      \\n            highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\\n      \\n            highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\\n            vLighting = ambientLight + (directionalLightColor * directional);\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n\\n        uniform sampler2D uSampler;\\n\\n        varying highp vec3 vLighting;\\n        varying highp vec2 vTextureCoord;\\n\\n    \\n        void main() {\\n            highp vec4 texelColor = texture2D(uSampler, vTextureCoord);\\n            gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\\n        }\\n    `,\\n    },\\n    mapAndColor:{\\n        vertex: `\\n        attribute vec3 a_position;\\n        attribute vec2 aTextureCoord;\\n        attribute vec3 aVertexNormal;\\n    \\n        uniform mat4 modelMatrix;\\n        uniform mat4 viewMatrix;\\n        uniform mat4 projMatrix;\\n        uniform mat4 uNormalMatrix;\\n    \\n        varying highp vec2 vTextureCoord;\\n        varying highp vec3 vLighting;\\n    \\n        void main() {\\n            gl_Position = projMatrix * viewMatrix * modelMatrix * vec4(a_position.xyz,1.0); //\\n            vTextureCoord = aTextureCoord;\\n            highp vec3 ambientLight = vec3(0.3, 0.3, 0.3);\\n            highp vec3 directionalLightColor = vec3(1, 1, 1);\\n            highp vec3 directionalVector = normalize(vec3(0.85, 0.8, 0.75));\\n      \\n            highp vec4 transformedNormal = uNormalMatrix * vec4(aVertexNormal, 1.0);\\n      \\n            highp float directional = max(dot(transformedNormal.xyz, directionalVector), 0.0);\\n            vLighting = ambientLight + (directionalLightColor * directional);\\n        }\\n    `,\\n        fragment: `\\n        precision mediump float;\\n\\n        uniform sampler2D uSampler;\\n        uniform vec4 v_color;\\n\\n        varying highp vec2 vTextureCoord;\\n        varying highp vec3 vLighting;\\n\\n    \\n        void main() {\\n            highp vec4 texelColor = texture2D(uSampler, vTextureCoord)*color;\\n            gl_FragColor = vec4(texelColor.rgb * vLighting, texelColor.a);\\n        }\\n    `,\\n    }\\n};\\n\\n\\n*/\\n\\n\\n// CONCATENATED MODULE: ./src/light/CoreLight.js\\n\\nclass CoreLight {\\n    constructor(){\\n        this.type = 'light';\\n        this.color = [];\\n        this.intensity = 0;\\n    }\\n    createDataToWebgl (){\\n        if (this.typeLight == 'ambient'){\\n            return {\\n                    color: this.color,\\n                    intensity:this.intensity,\\n                    type: this.typeLight,\\n            };\\n        } else {\\n            return {\\n                    color: this.color,\\n                    intensity: this.intensity,\\n                    positionLight: this.position,\\n                    shiniess: this.shininess,\\n                    specularColor: this.specularColor,\\n                    specularInt: this.specularInt,\\n                    k_vertex: this.k_vertex,\\n                    type: this.typeLight,\\n            };\\n        }\\n    }\\n}\\n\\n// CONCATENATED MODULE: ./src/light/AmbientLight.js\\n\\n\\nclass AmbientLight_AmbientLight extends CoreLight {\\n    constructor (){\\n        super();\\n        this.typeLight = 'ambient';\\n    }\\n\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/light/DirectionalLight.js\\n\\n\\n/*\\nconst BLACK = [0.0, 0.0, 0.0];\\nconst WHITE = [1.0, 1.0, 1.0];\\nconst RED   = [1.0, 0.0, 0.0];\\nconst GREEN = [0.0, 1.0, 0.0];\\nconst BLUE  = [0.0, 0.0, 1.0];\\nconst YELLOW = [0.6,1.0,0.5];//(60,100%,50%)\\n*/\\nclass DirectionalLight_DirectionalLight extends CoreLight{\\n    constructor (){\\n        super();\\n        this.typeLight = 'directional';\\n        this.position = new Coordinates3D();\\n        this.specularColor = [1.0,1.0,1.0];\\n        this.specularInt = 1.0;\\n        this.shininess = 10.0;\\n        this.k_vertex = 0.0;\\n    }\\n\\n\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/light/PointLight.js\\n\\n\\n\\nclass PointLight_PointLight extends CoreLight{\\n    constructor (){\\n        super();\\n        this.typeLight = 'point'; \\n        this.position = new Coordinates3D();\\n        this.specularColor = [1.0,1.0,1.0];\\n        this.specularInt = 1.0;\\n        this.shininess = 10.0;\\n        this.k_vertex = 1.0;\\n    }\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/geometry/PlaneGeometry.js\\n\\n\\n\\nclass PlaneGeometry_PlaneGeometry extends CoreGeometry {\\n    constructor (w,h,x,y,z){\\n        super();\\n        this.start = new Coordinates3D(x,y,z);\\n        this.w = w;\\n        this.h = h;\\n    }\\n    createVertex(){\\n        let x0 = this.start.x;\\n        let x1 = x0+ this.w;\\n        let y0 = this.start.y;\\n        let y1 = y0+this.h; \\n        let z0 = this.start.z;\\n\\n        let vertex =  [\\n            x0,y0,z0,\\n            x1,y0,z0,\\n            x0,y1,z0,\\n      \\n            x0,y1,z0,\\n            x1,y0,z0,\\n            x1,y1,z0,\\n        ];\\n        const mapCord2D = [\\n            0.0,  0.0,\\n            1.0,  0.0,\\n            0.0,  1.0,\\n            0.0,  1.0,\\n            1.0,  0.0,\\n            1.0,  1.0 \\n        ];\\n        const frontNormals = [\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n            0.0,  0.0,  1.0,\\n        ];\\n        const backNormals = [\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n            0.0,  0.0, -1.0,\\n        ];\\n        const topNormals = [\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n            0.0,  -1.0,  0.0,\\n        ];\\n        const bottomNormals = [\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n            0.0, 1.0,  0.0,\\n        ];\\n        const leftNormals = [\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n            -1.0,  0.0,  0.0,\\n        ];\\n        const rightNormals = [\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n            1.0,  0.0,  0.0,\\n        ];\\n\\n        this.partsGeometry = [\\n            this.createGeometry('part',vertex,mapCord2D,frontNormals),\\n        ];\\n\\n        //vertex = vertex.concat(frontRect.cord,backRect.cord,topVertex,bottomVertex,leftVertex,rightVertex);\\n        return this.partsGeometry;\\n    }\\n\\n}\\n\\n\\n// CONCATENATED MODULE: ./src/index.js\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nconst src_BLACK = [0.0, 0.0, 0.0, 1.0];\\nconst src_WHITE = [1.0, 1.0, 1.0, 1.0];\\nconst src_RED   = [1.0, 0.0, 0.0, 1.0];\\nconst src_GREEN = [0.0, 1.0, 0.0, 1.0];\\nconst src_BLUE  = [0.0, 0.0, 1.0, 1.0];\\n\\nlet src_image2 = new Image();\\nsrc_image2.src = '../tiles.jpeg';\\n\\nlet src_image = new Image();\\n//image.src = '../Devs_Title_Card.png';\\nsrc_image.src = '../westworld-4.jpeg';\\n\\n //image2.onload = function() {\\n  src_image.onload = function(){\\n    main(src_image,src_image2);\\n  };\\n //};\\n\\nfunction main (image1,image2){\\n  let canvas = document.getElementById('canvas');\\n  canvas.width = window.innerWidth * window.devicePixelRatio;\\n  canvas.height = window.innerHeight * window.devicePixelRatio;\\n  \\n  window.addEventListener('resize',function(){\\n    canvas.width = window.innerWidth * window.devicePixelRatio;\\n    canvas.height = window.innerHeight * window.devicePixelRatio;\\n  });\\n  \\n  // let image3 = new Image();\\n  // image3.src = '../tiles.jpeg';\\n  \\n  // let image = new Image();\\n  // //image.src = '../Devs_Title_Card.png';\\n  // image.src = '../westworld-4.jpeg';\\n  \\n  \\n  //westworld-4.jpeg\\n  \\n  let camera = new Camera_Camera; \\n  \\n  //camera.perspectiveSett.fov = 90 * Math.PI/180;\\n  //camera.perspectiveSett.zNear = 0.5;\\n  camera.perspectiveSett.zFar = 6000;\\n  camera.perspectiveSett.aspect = canvas.width/canvas.height;\\n  \\n  camera.ortographicSett.right = canvas.width;\\n  camera.ortographicSett.bottom = canvas.height;\\n  camera.ortographicSett.left = 0;\\n  camera.ortographicSett.top = 0;\\n  camera.ortographicSett.near = -3000;\\n  camera.ortographicSett.far = 3000;\\n  \\n  let fi = 0;\\n  let renderer = new WebGlRender(canvas);\\n  \\n  let boxGeom = new BoxGeometry_BoxGeometry(200,200,200,-200/2,-200/2,-200/2);\\n  let planeGeometry = new PlaneGeometry_PlaneGeometry(1000,1000,-1000/2,-1000/2);//-1000/2,-1000/2,-1000/2\\n  \\n  let boxMaterialData = {\\n    color: [1.0, 0.0, 0.5, 0.5],\\n  };\\n  let textMaterialv1 = {\\n    map: image1\\n  };\\n  let textMaterialv2 = {\\n    map: image1,\\n    color: src_RED,\\n  };\\n  let textMaterialv3 = {\\n    map: image2,\\n    //color: GREEN,\\n  };\\n\\n  let boxMaterialv2 = [\\n    new BasicMaterial_BasicMaterial ({color: src_RED}),\\n    new BasicMaterial_BasicMaterial ({color: src_GREEN}),\\n    new BasicMaterial_BasicMaterial ({color: src_BLUE}),\\n    new BasicMaterial_BasicMaterial ({color: [1.0, 0.0, 0.5, 0.5]}),\\n    new BasicMaterial_BasicMaterial ({color: [0.5, 1, 0.8, 1]}),\\n    new BasicMaterial_BasicMaterial ({color: [0.04, 0.96, 0.96, 1]})\\n  ]; \\n  let boxMaterialv5 = [\\n    new PhongMaterial_PhongMaterial ({color: src_RED}),\\n    new PhongMaterial_PhongMaterial ({color: src_GREEN}),\\n    new PhongMaterial_PhongMaterial ({color: src_BLUE}),\\n    new PhongMaterial_PhongMaterial ({color: [1.0, 0.0, 0.5, 1]}),\\n    new PhongMaterial_PhongMaterial ({color: [0.5, 1, 0.8, 1]}),\\n    new PhongMaterial_PhongMaterial ({color: [0.04, 0.96, 0.96, 1]}),\\n  ];\\n  let boxMaterialv3 = [\\n    new BasicMaterial_BasicMaterial ({color: [1.0, 0.0, 0.5, 1.0]}),\\n    new BasicMaterial_BasicMaterial(textMaterialv1)\\n    //new BasicMaterial ({color: [0.5, 1, 0, 1]}),\\n    //new BasicMaterial ({color: [1, 0, 0, 1]}),\\n    //new BasicMaterial ({color: [0.5, 1, 0, 1]}),\\n    //new BasicMaterial ({color: [0.3, 1, 0, 1]}),\\n  ];\\n  let colorBoxEdges = [\\n    [1, 0, 0, 1],\\n    [0, 0, 1, 1],\\n    [0.5, 1, 0, 1],\\n    [0.3, 1, 0, 1],\\n    [0.2, 0.6, 0.8, 1],\\n    [0, 0.5, 0.7, 1]\\n  ];\\n  \\n  let boxMaterialv1 = new BasicMaterial_BasicMaterial(boxMaterialData);\\n  let planematerial = new PhongMaterial_PhongMaterial(textMaterialv3);\\n  let boxMaterialv4 = new PhongMaterial_PhongMaterial(textMaterialv2);\\n  let boxMaterialv6 = new PhongMaterial_PhongMaterial(textMaterialv1);\\n  let boxMaterialv7 = new PhongMaterial_PhongMaterial(boxMaterialData);\\n  //console.log(boxMaterialv4);\\n\\n  let box2 = new Mesh_Mesh(boxGeom,boxMaterialv4);\\n  let box3 = new Mesh_Mesh(boxGeom,boxMaterialv6);\\n  let plane = new Mesh_Mesh(planeGeometry,planematerial);\\n  let box = new Mesh_Mesh(boxGeom,boxMaterialv2);\\n\\n\\n  \\n  //console.log(box);\\n  \\n  let scene = new Scene_Scene();\\n  \\n  scene.background = src_BLACK;\\n  \\n  const light = new AmbientLight_AmbientLight();\\n  light.color = [1.0, 1.0, 1.0];\\n  light.intensity = 0.0;\\n  \\n  const light2 = new DirectionalLight_DirectionalLight();\\n  light2.position.x = 0;\\n  light2.position.y = 0;\\n  light2.position.z = 200;\\n  light2.color = [1.0, 1.0, 1.0];\\n  light2.intensity = 1.0;\\n  \\n  \\n  const light3 = new PointLight_PointLight();\\n  // light3.position.y = -300;\\n  // light3.position.z = 300;\\n  light3.color = [1.0, 1.0, 1.0];\\n  light3.intensity = 1.0;\\n  light3.shininess = 200.0;\\n  light3.specularInt = 1.0;\\n  \\n  scene.add(light);\\n  scene.add(light3);\\n  scene.add(plane);\\n  scene.add(box);\\n  scene.add(box2);\\n  scene.add(box3);\\n\\n  \\n  plane.rotation.x = Math.PI/2;//180;\\n  //plane.rotation.x = 2*Math.PI;//180;\\n  plane.scale.x = 4;\\n  plane.scale.y = 4;\\n  camera.rotation.x  = 0.4;\\n  //camera.rotation.y = 45;\\n  \\n  let tPrev = 0;\\n  let dT = 0;\\n  \\n  \\n  // image.onload = function() {\\n  //   render();\\n  // };\\n  // image.onload = function() {\\n  //   image2.onload = function(){\\n  //     render();\\n  //   };\\n  // };\\n  \\n  render();\\n  function render (){  // render target \\n\\n    dT =  (window.performance.now()-tPrev)*60/1000;\\n    //console.log(dT,window.performance.now(),tPrev);\\n    fi += 0.005*dT;\\n  \\n    box.position.x = 0;//canvas.width/2;\\n    box.position.y = 0;//canvas.height/2;\\n    box.position.z = -500;//Math.sin(fi)*1500;\\n  \\n    box2.position.x = 500;//canvas.width/2;\\n    box2.position.y = 0;//canvas.height/2;\\n    box2.position.z = -500;//Math.sin(fi)*1500;\\n  \\n    box3.position.x = -500;//canvas.width/2;\\n    box3.position.y = 0;//canvas.height/2;\\n    box3.position.z = -500;//Math.sin(fi)*1500;\\n    //console.log(box.position.z);\\n  \\n    plane.position.x = 0;//canvas.width/2;\\n    plane.position.y = -600;//canvas.height/2;\\n    plane.position.z = -500;//Math.sin(fi)*1500;\\n    //plane.rotation.x = -fi;//180;\\n    //console.log(plane.rotation.x);\\n  \\n    //plane.rotation.x = fi;\\n  \\n    light3.position.y = 300; //* (Math.cos(fi));\\n    light3.position.z = 300 * (Math.cos(fi));\\n    //console.log(light3.position.z);\\n  \\n    box.rotation.x = fi;\\n    box.rotation.y = fi;\\n    box.rotation.z = fi;\\n  \\n    box2.rotation.x = Math.PI/2;\\n    //box2.rotation.y = fi;\\n    //box2.rotation.z = fi;\\n  \\n    //box3.rotation.x = -fi;\\n    //box3.rotation.y = fi;\\n    //box3.rotation.z = -fi;\\n  \\n    //camera.rotation.x = -fi;\\n    //console.log(camera.rotation.x);\\n  \\n    camera.position.y = 500;\\n    camera.position.z = 500;\\n  \\n    camera.ortographicSett.right = canvas.width;\\n    camera.ortographicSett.bottom = canvas.height;\\n  \\n    camera.perspectiveSett.aspect = canvas.width/canvas.height;\\n  \\n    renderer.render(scene,camera);\\n  \\n    tPrev = window.performance.now();\\n  \\n    requestAnimationFrame(render);\\n  }\\n}\\n\\n\\n\\n//# sourceURL=[module]\\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvQ29vcmRpbmF0ZXMzRC5qcz9kYzZkIiwid2VicGFjazovLy8uL3NyYy9tYXRoL01hdHJpeC5qcz8zNDE1Iiwid2VicGFjazovLy8uL3NyYy9wcm9ncmFtL1Byb2dyYW1SdWxlcy5qcz9iYzc3Iiwid2VicGFjazovLy8uL3NyYy9wcm9ncmFtL1dlYkdsUHJvZ3JhbXMuanM/ZWIxNCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvQ29yZU1hdGVyaWFsLmpzPzU2MTEiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGVyaWFsL0Jhc2ljTWF0ZXJpYWwuanM/YzdjNSIsIndlYnBhY2s6Ly8vLi9zcmMvY2FtZXJhL0NhbWVyYS5qcz9lMjFkIiwid2VicGFjazovLy8uL3NyYy9NZXNoLmpzPzZlNzMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dlb21ldHJ5L0NvcmVHZW9tZXRyeS5qcz84ZjA2Iiwid2VicGFjazovLy8uL3NyYy9nZW9tZXRyeS9SZWN0YW5ndWxhckdlb21ldHJ5LmpzPzU1YTkiLCJ3ZWJwYWNrOi8vLy4vc3JjL1NjZW5lLmpzPzFhMGUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2dlb21ldHJ5L1RyaWFuZ2xlR2VvbWV0cnkuanM/NGZmMSIsIndlYnBhY2s6Ly8vLi9zcmMvV2ViR2xSZW5kZXIuanM/ZWE4YyIsIndlYnBhY2s6Ly8vLi9zcmMvZ2VvbWV0cnkvQm94R2VvbWV0cnkuanM/OTY2MSIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvTWF0ZXJpYWwuanM/NzE3MCIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvVGV4dHVyZU1hdGVyaWFsLmpzPzhjYWYiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGVyaWFsL0dyYWRpZW50TWF0ZXJpYWwuanM/MjI4MSIsIndlYnBhY2s6Ly8vLi9zcmMvbWF0ZXJpYWwvTW9ub2Nocm9tZUNvbG9yLmpzPzMwYmIiLCJ3ZWJwYWNrOi8vLy4vc3JjL21hdGVyaWFsL1Bob25nTWF0ZXJpYWwuanM/N2FkMSIsIndlYnBhY2s6Ly8vLi9zcmMvbGlnaHQvQ29yZUxpZ2h0LmpzPzRjMmUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpZ2h0L0FtYmllbnRMaWdodC5qcz9jZDIwIiwid2VicGFjazovLy8uL3NyYy9saWdodC9EaXJlY3Rpb25hbExpZ2h0LmpzPzA0OTUiLCJ3ZWJwYWNrOi8vLy4vc3JjL2xpZ2h0L1BvaW50TGlnaHQuanM/NjdmZCIsIndlYnBhY2s6Ly8vLi9zcmMvZ2VvbWV0cnkvUGxhbmVHZW9tZXRyeS5qcz82OGIyIiwid2VicGFjazovLy8uL3NyYy9pbmRleC5qcz9iNjM1Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ1ZpRDs7QUFFakQsTUFBTSxhQUFNLEU7QUFDWjtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGFBQWE7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixhQUFhO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVrQjs7QUFFbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7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aUIsU0FBSTtBQUNyQixpQkFBaUIsU0FBSTtBQUNyQixrQkFBa0IsU0FBSTtBQUN0QixnQkFBZ0IsU0FBSTs7OztBQUlwQjs7QUFFQSxrQkFBa0IsV0FBSzs7QUFFdkIscUJBQXFCLFNBQUs7O0FBRTFCLG9CQUFvQix5QkFBWTtBQUNoQztBQUNBOztBQUVBLHFCQUFxQixpQ0FBZ0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EscUJBQXFCLHFCQUFVO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLCtCQUErQjtBQUMvQixpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFCQUFxQjs7QUFFckI7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2Qix1QkFBdUI7QUFDdkIsMEJBQTBCOztBQUUxQiwwQkFBMEI7QUFDMUIsd0JBQXdCO0FBQ3hCLDJCQUEyQjs7QUFFM0IsMkJBQTJCO0FBQzNCLHdCQUF3QjtBQUN4QiwyQkFBMkI7QUFDM0I7O0FBRUEseUJBQXlCO0FBQ3pCLDRCQUE0QjtBQUM1Qiw0QkFBNEI7QUFDNUIsNkJBQTZCO0FBQzdCOztBQUVBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSIsImZpbGUiOiIwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiXG5jbGFzcyBDb29yZGluYXRlczNEIHtcbiAgICBjb25zdHJ1Y3RvciAoeD0wLHk9MCx6PTApe1xuICAgICAgICB0aGlzLng9eDtcbiAgICAgICAgdGhpcy55PXk7XG4gICAgICAgIHRoaXMuej16O1xuICAgIH1cbiAgICBjbG9uZSgpe1xuICAgICAgICByZXR1cm4gbmV3IENvb3JkaW5hdGVzM0QodGhpcy54LHRoaXMueSx0aGlzLnopO1xuICAgIH1cbn1cbmV4cG9ydCB7IENvb3JkaW5hdGVzM0QgfTsiLCJpbXBvcnQgeyBDb29yZGluYXRlczNEIH0gZnJvbSBcIi4uL0Nvb3JkaW5hdGVzM0RcIjtcblxuY2xhc3MgTWF0cml4IHsgXG4gICAgICB3aW5kb3coZGF0YSl7XG4gICAgICAgIGxldCB3ID0gbmV3IENvb3JkaW5hdGVzM0QoZGF0YS54LGRhdGEueSxkYXRhLnopO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIDIgLyB3LngsIDAsIDAsIDAsXG4gICAgICAgICAgMCwgLTIgLyB3LnksIDAsIDAsXG4gICAgICAgICAgMCwgMCwgMiAvIHcueiwgMCwgICBcbiAgICAgICAgLTEsIDEsIDAsIDEsXG4gICAgICBdO1xuICAgICAgfVxuICAgICAgcGVyc3BlY3RpdmUoZGF0YSl7XG4gICAgICAgIGxldCBmb3ZJblJhZGlhbnMgPSBkYXRhLmZvdiAqIE1hdGguUEkvMTgwO1xuICAgICAgICBsZXQgZiA9IE1hdGgudGFuKE1hdGguUEkgKiAwLjUgLSAwLjUgKiBmb3ZJblJhZGlhbnMpO1xuICAgICAgICBsZXQgcmFuZ2VJbnYgPSAxLjAgLyAoZGF0YS56TmVhciAtIGRhdGEuekZhcik7XG4gICAgICAgIGxldCBhID0gZiAvIGRhdGEuYXNwZWN0O1xuICAgICAgICBsZXQgYiA9IChkYXRhLnpOZWFyICsgZGF0YS56RmFyKSAqIHJhbmdlSW52O1xuICAgICAgICBsZXQgYyA9IGRhdGEuek5lYXIgKiBkYXRhLnpGYXIgKiByYW5nZUludiAqIDIuMDtcblxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIGEsIDAsICAwLCAwLFxuICAgICAgICAgIDAsIGYsIDAsIDAsXG4gICAgICAgICAgMCwgMCwgIGIsIC0xLFxuICAgICAgICAgIDAsIDAsICBjLCAwLFxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgb3J0b2dyYXBoaWMoZGF0YSl7XG4gICAgICAgIGxldCB3ID0gZGF0YS5yaWdodCAtIGRhdGEubGVmdDtcbiAgICAgICAgbGV0IGggPSBkYXRhLnRvcCAtIGRhdGEuYm90dG9tO1xuICAgICAgICBsZXQgZCA9IGRhdGEuZmFyIC0gZGF0YS5uZWFyO1xuXG4gICAgICAgIGxldCB0eCA9IC0oKGRhdGEucmlnaHQgKyBkYXRhLmxlZnQpL3cpO1xuICAgICAgICBsZXQgdHkgPSAtKChkYXRhLnRvcCArIGRhdGEuYm90dG9tKS9oKTtcbiAgICAgICAgbGV0IHR6ID0gLSgoZGF0YS5mYXIgKyBkYXRhLm5lYXIpL2QpO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIDIgLyB3LCAwLCAgICAgMCwgICAgICAwLFxuICAgICAgICAgIDAsICAgICAyIC8gaCwgMCwgICAgICAwLFxuICAgICAgICAgIDAsICAgICAwLCAgICAgLTIgLyBkLCAwLCAgIFxuICAgICAgICAgIHR4LCAgICB0eSwgICAgdHosICAgICAxLFxuICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHNjYWxlKGRhdGEpe1xuICAgICAgICBsZXQgcyA9IG5ldyBDb29yZGluYXRlczNEKGRhdGEueCxkYXRhLnksZGF0YS56KVxuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgIHMueCwwLDAsMCxcbiAgICAgICAgICAwLHMueSwwLDAsXG4gICAgICAgICAgMCwwLHMueiwwLFxuICAgICAgICAgIDAsMCwwLDFcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHRyYW5zbGF0ZShkYXRhPTApe1xuICAgICAgICBsZXQgdCA9IG5ldyBDb29yZGluYXRlczNEKGRhdGEueCxkYXRhLnksZGF0YS56KTtcbiAgICAgICAgcmV0dXJuW1xuICAgICAgICAgIDEsMCwwLDAsXG4gICAgICAgICAgMCwxLDAsMCxcbiAgICAgICAgICAwLDAsMSwwLFxuICAgICAgICAgIHQueCx0LnksdC56LDFcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHhSb3RhdGlvbihhPTApIHtcbiAgICAgICAgbGV0IGMgPSBNYXRoLmNvcyhhKTtcbiAgICAgICAgbGV0IHMgPSBNYXRoLnNpbihhKTtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICAxLCAwLCAwLCAwLFxuICAgICAgICAgIDAsIGMsIC1zLCAwLFxuICAgICAgICAgIDAsIHMsIGMsIDAsXG4gICAgICAgICAgMCwgMCwgMCwgMSxcbiAgICAgICAgXTtcbiAgICAgIH1cbiAgICAgIHlSb3RhdGlvbiAoYT0wKSB7XG4gICAgICAgIGxldCBjID0gTWF0aC5jb3MoYSk7XG4gICAgICAgIGxldCBzID0gTWF0aC5zaW4oYSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgYywgMCwgcywgMCxcbiAgICAgICAgICAwLCAxLCAwLCAwLFxuICAgICAgICAgIC1zLCAwLCBjLCAwLFxuICAgICAgICAgIDAsIDAsIDAsIDEsXG4gICAgICAgIF07XG4gICAgICB9XG4gICAgICB6Um90YXRpb24oYT0wKXtcbiAgICAgICAgcmV0dXJuIFtcbiAgICAgICAgICBNYXRoLmNvcyhhKSwgLU1hdGguc2luKGEpLCAgICAwLCAgICAwLFxuICAgICAgICAgIE1hdGguc2luKGEpLCAgTWF0aC5jb3MoYSksICAgIDAsICAgIDAsXG4gICAgICAgICAgICAgICAwLCAgICAgICAwLCAgICAxLCAgICAwLFxuICAgICAgICAgICAgICAgMCwgICAgICAgMCwgICAgMCwgICAgMVxuICAgICAgICBdO1xuICAgICAgfVxuICAgICAgbXVsdGlwbHlNYXRyaXhBbmRQb2ludChtYXRyaXgsIHBvaW50KSB7XG4gICAgICAgIC8vIEdpdmUgYSBzaW1wbGUgdmFyaWFibGUgbmFtZSB0byBlYWNoIHBhcnQgb2YgdGhlIG1hdHJpeCwgYSBjb2x1bW4gYW5kIHJvdyBudW1iZXJcbiAgICAgICAgbGV0IGMwcjAgPSBtYXRyaXhbMF0sIGMxcjAgPSBtYXRyaXhbMV0sIGMycjAgPSBtYXRyaXhbMl0sIGMzcjAgPSBtYXRyaXhbM107XG4gICAgICAgIGxldCBjMHIxID0gbWF0cml4WzRdLCBjMXIxID0gbWF0cml4WzVdLCBjMnIxID0gbWF0cml4WzZdLCBjM3IxID0gbWF0cml4WzddO1xuICAgICAgICBsZXQgYzByMiA9IG1hdHJpeFs4XSwgYzFyMiA9IG1hdHJpeFs5XSwgYzJyMiA9IG1hdHJpeFsxMF0sIGMzcjIgPSBtYXRyaXhbMTFdO1xuICAgICAgICBsZXQgYzByMyA9IG1hdHJpeFsxMl0sIGMxcjMgPSBtYXRyaXhbMTNdLCBjMnIzID0gbWF0cml4WzE0XSwgYzNyMyA9IG1hdHJpeFsxNV07XG4gICAgICBcbiAgICAgICAgLy8gTm93IHNldCBzb21lIHNpbXBsZSBuYW1lcyBmb3IgdGhlIHBvaW50XG4gICAgICAgIGxldCB4ID0gcG9pbnRbMF07XG4gICAgICAgIGxldCB5ID0gcG9pbnRbMV07XG4gICAgICAgIGxldCB6ID0gcG9pbnRbMl07XG4gICAgICAgIGxldCB3ID0gcG9pbnRbM107XG4gICAgICBcbiAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IGFnYWluc3QgZWFjaCBwYXJ0IG9mIHRoZSAxc3QgY29sdW1uLCB0aGVuIGFkZCB0b2dldGhlclxuICAgICAgICBsZXQgcmVzdWx0WCA9ICh4ICogYzByMCkgKyAoeSAqIGMwcjEpICsgKHogKiBjMHIyKSArICh3ICogYzByMyk7XG4gICAgICBcbiAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IGFnYWluc3QgZWFjaCBwYXJ0IG9mIHRoZSAybmQgY29sdW1uLCB0aGVuIGFkZCB0b2dldGhlclxuICAgICAgICBsZXQgcmVzdWx0WSA9ICh4ICogYzFyMCkgKyAoeSAqIGMxcjEpICsgKHogKiBjMXIyKSArICh3ICogYzFyMyk7XG4gICAgICBcbiAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IGFnYWluc3QgZWFjaCBwYXJ0IG9mIHRoZSAzcmQgY29sdW1uLCB0aGVuIGFkZCB0b2dldGhlclxuICAgICAgICBsZXQgcmVzdWx0WiA9ICh4ICogYzJyMCkgKyAoeSAqIGMycjEpICsgKHogKiBjMnIyKSArICh3ICogYzJyMyk7XG4gICAgICBcbiAgICAgICAgLy8gTXVsdGlwbHkgdGhlIHBvaW50IGFnYWluc3QgZWFjaCBwYXJ0IG9mIHRoZSA0dGggY29sdW1uLCB0aGVuIGFkZCB0b2dldGhlclxuICAgICAgICBsZXQgcmVzdWx0VyA9ICh4ICogYzNyMCkgKyAoeSAqIGMzcjEpICsgKHogKiBjM3IyKSArICh3ICogYzNyMyk7XG4gICAgICBcbiAgICAgICAgcmV0dXJuIFtyZXN1bHRYLCByZXN1bHRZLCByZXN1bHRaLCByZXN1bHRXXTtcbiAgICAgIH1cbiAgICAgIG11bHRpcGx5KGEsYil7XG4gICAgICAgIHZhciBhMDAgPSBhWzAgKiA0ICsgMF07XG4gICAgICAgIHZhciBhMDEgPSBhWzAgKiA0ICsgMV07XG4gICAgICAgIHZhciBhMDIgPSBhWzAgKiA0ICsgMl07XG4gICAgICAgIHZhciBhMDMgPSBhWzAgKiA0ICsgM107XG4gICAgICAgIHZhciBhMTAgPSBhWzEgKiA0ICsgMF07XG4gICAgICAgIHZhciBhMTEgPSBhWzEgKiA0ICsgMV07XG4gICAgICAgIHZhciBhMTIgPSBhWzEgKiA0ICsgMl07XG4gICAgICAgIHZhciBhMTMgPSBhWzEgKiA0ICsgM107XG4gICAgICAgIHZhciBhMjAgPSBhWzIgKiA0ICsgMF07XG4gICAgICAgIHZhciBhMjEgPSBhWzIgKiA0ICsgMV07XG4gICAgICAgIHZhciBhMjIgPSBhWzIgKiA0ICsgMl07XG4gICAgICAgIHZhciBhMjMgPSBhWzIgKiA0ICsgM107XG4gICAgICAgIHZhciBhMzAgPSBhWzMgKiA0ICsgMF07XG4gICAgICAgIHZhciBhMzEgPSBhWzMgKiA0ICsgMV07XG4gICAgICAgIHZhciBhMzIgPSBhWzMgKiA0ICsgMl07XG4gICAgICAgIHZhciBhMzMgPSBhWzMgKiA0ICsgM107XG4gICAgICAgIHZhciBiMDAgPSBiWzAgKiA0ICsgMF07XG4gICAgICAgIHZhciBiMDEgPSBiWzAgKiA0ICsgMV07XG4gICAgICAgIHZhciBiMDIgPSBiWzAgKiA0ICsgMl07XG4gICAgICAgIHZhciBiMDMgPSBiWzAgKiA0ICsgM107XG4gICAgICAgIHZhciBiMTAgPSBiWzEgKiA0ICsgMF07XG4gICAgICAgIHZhciBiMTEgPSBiWzEgKiA0ICsgMV07XG4gICAgICAgIHZhciBiMTIgPSBiWzEgKiA0ICsgMl07XG4gICAgICAgIHZhciBiMTMgPSBiWzEgKiA0ICsgM107XG4gICAgICAgIHZhciBiMjAgPSBiWzIgKiA0ICsgMF07XG4gICAgICAgIHZhciBiMjEgPSBiWzIgKiA0ICsgMV07XG4gICAgICAgIHZhciBiMjIgPSBiWzIgKiA0ICsgMl07XG4gICAgICAgIHZhciBiMjMgPSBiWzIgKiA0ICsgM107XG4gICAgICAgIHZhciBiMzAgPSBiWzMgKiA0ICsgMF07XG4gICAgICAgIHZhciBiMzEgPSBiWzMgKiA0ICsgMV07XG4gICAgICAgIHZhciBiMzIgPSBiWzMgKiA0ICsgMl07XG4gICAgICAgIHZhciBiMzMgPSBiWzMgKiA0ICsgM107XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgYjAwICogYTAwICsgYjAxICogYTEwICsgYjAyICogYTIwICsgYjAzICogYTMwLFxuICAgICAgICAgIGIwMCAqIGEwMSArIGIwMSAqIGExMSArIGIwMiAqIGEyMSArIGIwMyAqIGEzMSxcbiAgICAgICAgICBiMDAgKiBhMDIgKyBiMDEgKiBhMTIgKyBiMDIgKiBhMjIgKyBiMDMgKiBhMzIsXG4gICAgICAgICAgYjAwICogYTAzICsgYjAxICogYTEzICsgYjAyICogYTIzICsgYjAzICogYTMzLFxuICAgICAgICAgIGIxMCAqIGEwMCArIGIxMSAqIGExMCArIGIxMiAqIGEyMCArIGIxMyAqIGEzMCxcbiAgICAgICAgICBiMTAgKiBhMDEgKyBiMTEgKiBhMTEgKyBiMTIgKiBhMjEgKyBiMTMgKiBhMzEsXG4gICAgICAgICAgYjEwICogYTAyICsgYjExICogYTEyICsgYjEyICogYTIyICsgYjEzICogYTMyLFxuICAgICAgICAgIGIxMCAqIGEwMyArIGIxMSAqIGExMyArIGIxMiAqIGEyMyArIGIxMyAqIGEzMyxcbiAgICAgICAgICBiMjAgKiBhMDAgKyBiMjEgKiBhMTAgKyBiMjIgKiBhMjAgKyBiMjMgKiBhMzAsXG4gICAgICAgICAgYjIwICogYTAxICsgYjIxICogYTExICsgYjIyICogYTIxICsgYjIzICogYTMxLFxuICAgICAgICAgIGIyMCAqIGEwMiArIGIyMSAqIGExMiArIGIyMiAqIGEyMiArIGIyMyAqIGEzMixcbiAgICAgICAgICBiMjAgKiBhMDMgKyBiMjEgKiBhMTMgKyBiMjIgKiBhMjMgKyBiMjMgKiBhMzMsXG4gICAgICAgICAgYjMwICogYTAwICsgYjMxICogYTEwICsgYjMyICogYTIwICsgYjMzICogYTMwLFxuICAgICAgICAgIGIzMCAqIGEwMSArIGIzMSAqIGExMSArIGIzMiAqIGEyMSArIGIzMyAqIGEzMSxcbiAgICAgICAgICBiMzAgKiBhMDIgKyBiMzEgKiBhMTIgKyBiMzIgKiBhMjIgKyBiMzMgKiBhMzIsXG4gICAgICAgICAgYjMwICogYTAzICsgYjMxICogYTEzICsgYjMyICogYTIzICsgYjMzICogYTMzLFxuICAgICAgICBdOyAgIFxuICAgICAgfVxuICAgICAgaW52ZXJ0KGEpIHtcbiAgICAgIGxldCBvdXQgPSBbXTtcbiAgICAgIGxldCBhMDAgPSBhWzBdLFxuICAgICAgICBhMDEgPSBhWzFdLFxuICAgICAgICBhMDIgPSBhWzJdLFxuICAgICAgICBhMDMgPSBhWzNdO1xuICAgICAgbGV0IGExMCA9IGFbNF0sXG4gICAgICAgIGExMSA9IGFbNV0sXG4gICAgICAgIGExMiA9IGFbNl0sXG4gICAgICAgIGExMyA9IGFbN107XG4gICAgICBsZXQgYTIwID0gYVs4XSxcbiAgICAgICAgYTIxID0gYVs5XSxcbiAgICAgICAgYTIyID0gYVsxMF0sXG4gICAgICAgIGEyMyA9IGFbMTFdO1xuICAgICAgbGV0IGEzMCA9IGFbMTJdLFxuICAgICAgICBhMzEgPSBhWzEzXSxcbiAgICAgICAgYTMyID0gYVsxNF0sXG4gICAgICAgIGEzMyA9IGFbMTVdO1xuICAgIFxuICAgICAgbGV0IGIwMCA9IGEwMCAqIGExMSAtIGEwMSAqIGExMDtcbiAgICAgIGxldCBiMDEgPSBhMDAgKiBhMTIgLSBhMDIgKiBhMTA7XG4gICAgICBsZXQgYjAyID0gYTAwICogYTEzIC0gYTAzICogYTEwO1xuICAgICAgbGV0IGIwMyA9IGEwMSAqIGExMiAtIGEwMiAqIGExMTtcbiAgICAgIGxldCBiMDQgPSBhMDEgKiBhMTMgLSBhMDMgKiBhMTE7XG4gICAgICBsZXQgYjA1ID0gYTAyICogYTEzIC0gYTAzICogYTEyO1xuICAgICAgbGV0IGIwNiA9IGEyMCAqIGEzMSAtIGEyMSAqIGEzMDtcbiAgICAgIGxldCBiMDcgPSBhMjAgKiBhMzIgLSBhMjIgKiBhMzA7XG4gICAgICBsZXQgYjA4ID0gYTIwICogYTMzIC0gYTIzICogYTMwO1xuICAgICAgbGV0IGIwOSA9IGEyMSAqIGEzMiAtIGEyMiAqIGEzMTtcbiAgICAgIGxldCBiMTAgPSBhMjEgKiBhMzMgLSBhMjMgKiBhMzE7XG4gICAgICBsZXQgYjExID0gYTIyICogYTMzIC0gYTIzICogYTMyO1xuICAgIFxuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSBkZXRlcm1pbmFudFxuICAgICAgbGV0IGRldCA9XG4gICAgICAgIGIwMCAqIGIxMSAtIGIwMSAqIGIxMCArIGIwMiAqIGIwOSArIGIwMyAqIGIwOCAtIGIwNCAqIGIwNyArIGIwNSAqIGIwNjtcbiAgICBcbiAgICAgIGlmICghZGV0KSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgZGV0ID0gMS4wIC8gZGV0O1xuICAgIFxuICAgICAgb3V0WzBdID0gKGExMSAqIGIxMSAtIGExMiAqIGIxMCArIGExMyAqIGIwOSkgKiBkZXQ7XG4gICAgICBvdXRbMV0gPSAoYTAyICogYjEwIC0gYTAxICogYjExIC0gYTAzICogYjA5KSAqIGRldDtcbiAgICAgIG91dFsyXSA9IChhMzEgKiBiMDUgLSBhMzIgKiBiMDQgKyBhMzMgKiBiMDMpICogZGV0O1xuICAgICAgb3V0WzNdID0gKGEyMiAqIGIwNCAtIGEyMSAqIGIwNSAtIGEyMyAqIGIwMykgKiBkZXQ7XG4gICAgICBvdXRbNF0gPSAoYTEyICogYjA4IC0gYTEwICogYjExIC0gYTEzICogYjA3KSAqIGRldDtcbiAgICAgIG91dFs1XSA9IChhMDAgKiBiMTEgLSBhMDIgKiBiMDggKyBhMDMgKiBiMDcpICogZGV0O1xuICAgICAgb3V0WzZdID0gKGEzMiAqIGIwMiAtIGEzMCAqIGIwNSAtIGEzMyAqIGIwMSkgKiBkZXQ7XG4gICAgICBvdXRbN10gPSAoYTIwICogYjA1IC0gYTIyICogYjAyICsgYTIzICogYjAxKSAqIGRldDtcbiAgICAgIG91dFs4XSA9IChhMTAgKiBiMTAgLSBhMTEgKiBiMDggKyBhMTMgKiBiMDYpICogZGV0O1xuICAgICAgb3V0WzldID0gKGEwMSAqIGIwOCAtIGEwMCAqIGIxMCAtIGEwMyAqIGIwNikgKiBkZXQ7XG4gICAgICBvdXRbMTBdID0gKGEzMCAqIGIwNCAtIGEzMSAqIGIwMiArIGEzMyAqIGIwMCkgKiBkZXQ7XG4gICAgICBvdXRbMTFdID0gKGEyMSAqIGIwMiAtIGEyMCAqIGIwNCAtIGEyMyAqIGIwMCkgKiBkZXQ7XG4gICAgICBvdXRbMTJdID0gKGExMSAqIGIwNyAtIGExMCAqIGIwOSAtIGExMiAqIGIwNikgKiBkZXQ7XG4gICAgICBvdXRbMTNdID0gKGEwMCAqIGIwOSAtIGEwMSAqIGIwNyArIGEwMiAqIGIwNikgKiBkZXQ7XG4gICAgICBvdXRbMTRdID0gKGEzMSAqIGIwMSAtIGEzMCAqIGIwMyAtIGEzMiAqIGIwMCkgKiBkZXQ7XG4gICAgICBvdXRbMTVdID0gKGEyMCAqIGIwMyAtIGEyMSAqIGIwMSArIGEyMiAqIGIwMCkgKiBkZXQ7XG4gICAgXG4gICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgdHJhbnNwb3NlKGEpIHtcbiAgICAgICAgLy8gSWYgd2UgYXJlIHRyYW5zcG9zaW5nIG91cnNlbHZlcyB3ZSBjYW4gc2tpcCBhIGZldyBzdGVwcyBidXQgaGF2ZSB0byBjYWNoZSBzb21lIHZhbHVlc1xuICAgICAgICBsZXQgb3V0ID0gW107XG5cbiAgICAgICAgICBvdXRbMF0gPSBhWzBdO1xuICAgICAgICAgIG91dFsxXSA9IGFbNF07XG4gICAgICAgICAgb3V0WzJdID0gYVs4XTtcbiAgICAgICAgICBvdXRbM10gPSBhWzEyXTtcbiAgICAgICAgICBvdXRbNF0gPSBhWzFdO1xuICAgICAgICAgIG91dFs1XSA9IGFbNV07XG4gICAgICAgICAgb3V0WzZdID0gYVs5XTtcbiAgICAgICAgICBvdXRbN10gPSBhWzEzXTtcbiAgICAgICAgICBvdXRbOF0gPSBhWzJdO1xuICAgICAgICAgIG91dFs5XSA9IGFbNl07XG4gICAgICAgICAgb3V0WzEwXSA9IGFbMTBdO1xuICAgICAgICAgIG91dFsxMV0gPSBhWzE0XTtcbiAgICAgICAgICBvdXRbMTJdID0gYVszXTtcbiAgICAgICAgICBvdXRbMTNdID0gYVs3XTtcbiAgICAgICAgICBvdXRbMTRdID0gYVsxMV07XG4gICAgICAgICAgb3V0WzE1XSA9IGFbMTVdO1xuICAgICAgICBcbiAgICAgIFxuICAgICAgICByZXR1cm4gb3V0O1xuICAgICAgfVxuICAgICAgbXVsdGlwbHlUb01vZGVsKGRhdGFQb3NpdGlvbixkYXRhU2NhbGUsZGF0YVJvdGF0aW9uKXtcbiAgICAgICAgbGV0IG1vZGVsTWF0cml4ID0gdGhpcy5tdWx0aXBseSh0aGlzLnRyYW5zbGF0ZShkYXRhUG9zaXRpb24pLHRoaXMueFJvdGF0aW9uKGRhdGFSb3RhdGlvbi54KSk7XG4gICAgICAgICAgICBtb2RlbE1hdHJpeCA9IHRoaXMubXVsdGlwbHkobW9kZWxNYXRyaXgsdGhpcy55Um90YXRpb24oZGF0YVJvdGF0aW9uLnkpKTtcbiAgICAgICAgICAgIG1vZGVsTWF0cml4ID0gdGhpcy5tdWx0aXBseShtb2RlbE1hdHJpeCx0aGlzLnpSb3RhdGlvbihkYXRhUm90YXRpb24ueikpO1xuICAgICAgICAgICAgbW9kZWxNYXRyaXggPSB0aGlzLm11bHRpcGx5KG1vZGVsTWF0cml4LHRoaXMuc2NhbGUoZGF0YVNjYWxlKSk7XG4gICAgICAgIHJldHVybiBtb2RlbE1hdHJpeDtcbiAgICAgIH1cbiAgICAgIGludmVydE1vZGVsTWF0cml4KGRhdGFQb3NpdGlvbixkYXRhU2NhbGUsZGF0YVJvdGF0aW9uKXtcbiAgICAgICAgcmV0dXJuIHRoaXMuaW52ZXJ0KHRoaXMubXVsdGlwbHlUb01vZGVsKGRhdGFQb3NpdGlvbixkYXRhU2NhbGUsZGF0YVJvdGF0aW9uKSk7XG4gICAgICB9XG4gICAgICBub3JtYWxpemUodikge1xuICAgICAgICBsZXQgZHN0ID0gW107XG4gICAgICAgIGxldCBsZW5ndGggPSBNYXRoLnNxcnQodlswXSAqIHZbMF0gKyB2WzFdICogdlsxXSArIHZbMl0gKiB2WzJdKTtcbiAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGRpdmlkZSBieSAwLlxuICAgICAgICBpZiAobGVuZ3RoID4gMC4wMDAwMSkge1xuICAgICAgICAgIGRzdFswXSA9IHZbMF0gLyBsZW5ndGg7XG4gICAgICAgICAgZHN0WzFdID0gdlsxXSAvIGxlbmd0aDtcbiAgICAgICAgICBkc3RbMl0gPSB2WzJdIC8gbGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkc3Q7XG4gICAgICB9XG59XG5cbmV4cG9ydCB7IE1hdHJpeCB9O1xuXG4vKiAgIC8vIGFub3RoZXIgdmFyaWFudCBjcmVhdGUgbWF0cml4IFxuICAgICAgY3JlYXRlT3J0b2dyYXBoaWMoZGF0YSl7XG4gICAgICAgIGxldCBsZWZ0ID0gZGF0YS5sZWZ0O1xuICAgICAgICBsZXQgcmlnaHQgPSBkYXRhLnJpZ2h0O1xuICAgICAgICBsZXQgdG9wID0gZGF0YS50b3A7XG4gICAgICAgIGxldCBib3R0b20gPSBkYXRhLmJvdHRvbTtcbiAgICAgICAgbGV0IG5lYXIgPSBkYXRhLm5lYXI7XG4gICAgICAgIGxldCBmYXIgPSBkYXRhLmZhcjtcblxuICAgICAgICBsZXQgTSA9IFtdO1xuXG4gICAgICAgIGxldCB3aWR0aFJhdGlvICA9IDEuMCAvIChyaWdodCAtIGxlZnQpO1xuICAgICAgICBsZXQgaGVpZ2h0UmF0aW8gPSAxLjAgLyAodG9wIC0gYm90dG9tKTtcbiAgICAgICAgbGV0IGRlcHRoUmF0aW8gID0gMS4wIC8gKGZhciAtIG5lYXIpO1xuICAgIFxuICAgICAgICBsZXQgc3ggPSAyICogd2lkdGhSYXRpbztcbiAgICAgICAgbGV0IHN5ID0gMiAqIGhlaWdodFJhdGlvO1xuICAgICAgICBsZXQgc3ogPSAtMiAqIGRlcHRoUmF0aW87XG4gICAgXG4gICAgICAgIGxldCB0eCA9IC0ocmlnaHQgKyBsZWZ0KSAqIHdpZHRoUmF0aW87XG4gICAgICAgIGxldCB0eSA9IC0odG9wICsgYm90dG9tKSAqIGhlaWdodFJhdGlvO1xuICAgICAgICBsZXQgdHogPSAtKGZhciArIG5lYXIpICogZGVwdGhSYXRpbztcbiAgICBcbiAgICAgICAgTVswXSA9IHN4OyAgTVs0XSA9IDA7ICAgTVs4XSA9IDA7ICAgTVsxMl0gPSB0eDtcbiAgICAgICAgTVsxXSA9IDA7ICAgTVs1XSA9IHN5OyAgTVs5XSA9IDA7ICAgTVsxM10gPSB0eTtcbiAgICAgICAgTVsyXSA9IDA7ICAgTVs2XSA9IDA7ICAgTVsxMF0gPSBzejsgTVsxNF0gPSB0ejtcbiAgICAgICAgTVszXSA9IDA7ICAgTVs3XSA9IDA7ICAgTVsxMV0gPSAwOyAgTVsxNV0gPSAxO1xuICAgIFxuICAgICAgICByZXR1cm4gTTtcbiAgICAgIH1cbiAgICAgIGNyZWF0ZUZydXN0dW0obGVmdCwgcmlnaHQsIGJvdHRvbSwgdG9wLCBuZWFyLCBmYXIpe1xuICAgICAgICBsZXQgTSA9IFtdO1xuICAgICAgICBsZXQgc3ggPSAyICogbmVhciAvIChyaWdodCAtIGxlZnQpO1xuICAgICAgICB2YXIgc3kgPSAyICogbmVhciAvICh0b3AgLSBib3R0b20pO1xuICBcbiAgICAgICAgbGV0IGMyID0gLSAoZmFyICsgbmVhcikgLyAoZmFyIC0gbmVhcik7XG4gICAgICAgIGxldCBjMSA9IDIgKiBuZWFyICogZmFyIC8gKG5lYXIgLSBmYXIpO1xuXG4gICAgICAgIGxldCBBID0gKHJpZ2h0ICsgbGVmdCkgLyAocmlnaHQgLSBsZWZ0KTtcbiAgICAgICAgbGV0IEIgPSAodG9wICsgYm90dG9tKSAvICh0b3AgLSBib3R0b20pO1xuICBcbiAgICAgICAgbGV0IHR4ID0gLW5lYXIgKiAobGVmdCArIHJpZ2h0KSAvIChyaWdodCAtIGxlZnQpO1xuICAgICAgICBsZXQgdHkgPSAtbmVhciAqIChib3R0b20gKyB0b3ApIC8gKHRvcCAtIGJvdHRvbSk7XG4gIFxuICAgICAgICBNWzBdID0gc3g7IE1bNF0gPSAwOyAgTVs4XSA9IDA7ICAgIE1bMTJdID0gdHg7XG4gICAgICAgIE1bMV0gPSAwOyAgTVs1XSA9IC1zeTsgTVs5XSA9IDA7ICAgIE1bMTNdID0gdHk7XG4gICAgICAgIE1bMl0gPSAwOyAgTVs2XSA9IDA7ICBNWzEwXSA9IGMyOyAgTVsxNF0gPSBjMTtcbiAgICAgICAgTVszXSA9IDA7ICBNWzddID0gMDsgIE1bMTFdID0gLTE7ICBNWzE1XSA9IDA7XG5cbiAgICAgICAgcmV0dXJuIE07XG4gICAgICB9XG4gICAgICBjcmVhdGVQZXJzcGVjdGl2ZShkYXRhKXtcbiAgICAgICBsZXQgZm92eSA9IGRhdGEuZm92O1xuICAgICAgIGxldCBhc3BlY3QgPSBkYXRhLmFzcGVjdDtcbiAgICAgICBsZXQgbmVhciA9IGRhdGEuek5lYXI7XG4gICAgICAgbGV0IGZhciA9IGRhdGEuekZhcjtcbiAgICAgICBcbiAgICAgICBsZXQgaGFsZl9mb3Z5ID0gKGZvdnkgKiBNYXRoLlBJLzE4MCkgLyAyO1xuXG4gICAgICAgbGV0IHRvcCA9IG5lYXIgKiBNYXRoLnRhbihoYWxmX2ZvdnkpO1xuICAgICAgIGxldCBib3R0b20gPSAtdG9wO1xuICAgICAgIGxldCByaWdodCA9IHRvcCAqIGFzcGVjdDtcbiAgICAgICBsZXQgbGVmdCA9IC1yaWdodDtcbiBcbiAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVGcnVzdHVtKGxlZnQsIHJpZ2h0LCBib3R0b20sIHRvcCwgbmVhciwgZmFyKTtcbiAgICAgIH1cblxuKi8iLCJpbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi4vbWF0aC9NYXRyaXhcIjtcblxuY29uc3QgQkxBQ0sgPSBbMC4wLCAwLjAsIDAuMF07XG5jb25zdCBXSElURSA9IFsxLjAsIDEuMCwgMS4wXTtcbmNvbnN0IFJFRCAgID0gWzEuMCwgMC4wLCAwLjBdO1xuY29uc3QgR1JFRU4gPSBbMC4wLCAxLjAsIDAuMF07XG5jb25zdCBCTFVFICA9IFswLjAsIDAuMCwgMS4wXTtcbmNvbnN0IFlFTExPVyA9IFswLjYsMS4wLDAuNV07Ly8oNjAsMTAwJSw1MCUpXG5cbmNsYXNzIFByb2dyYW1SdWxlcyB7XG4gICAgY29uc3RydWN0b3IgKGdsLHByb2dyYW0sYXRyTmFtZXMsdW5pZk5hbWVzKXtcbiAgICAgICAgdGhpcy5nbCA9IGdsO1xuICAgICAgICB0aGlzLnByb2dyYW0gPSBwcm9ncmFtO1xuICAgICAgICB0aGlzLmFOYW1lcyA9IGF0ck5hbWVzO1xuICAgICAgICB0aGlzLnVOYW1lcyA9IHVuaWZOYW1lcztcbiAgICAgICAgdGhpcy50ZXh0QXRyVXBkdCA9IHRydWU7XG4gICBcbiAgICAgICAgdGhpcy5nZXRBdHJMb2NhdGlvbnModGhpcy5nbCx0aGlzLnByb2dyYW0sdGhpcy5hTmFtZXMpO1xuICAgICAgICB0aGlzLmdldFVuaWZMb2NhdGlvbnModGhpcy5nbCx0aGlzLnByb2dyYW0sdGhpcy51TmFtZXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUJ1ZmZlcnMoKTtcbiAgICB9XG4gICAgY2xlYXJCdWZmZXJzKCl7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLmFEYXRhKXtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlQnVmZmVyKHRoaXMuYnVmZmVyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVCdWZmZXJzKCl7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gdGhpcy5hRGF0YSl7XG4gICAgICAgICAgICB0aGlzLmJ1ZmZlcnNba2V5XSA9IHRoaXMuZ2wuY3JlYXRlQnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0VW5pZm9ybShtb2RlbE1hdHJpeCxpbnZUck1vZGVsTWF0cml4LHJ1bGVzLGNhbWVyYSxsaWdodCl7XG4gICAgICAgIGZvciAobGV0IGtleSBpbiB0aGlzLnVEYXRhKXtcbiAgICAgICAgICAgIHN3aXRjaCAoa2V5KXtcbiAgICAgICAgICAgICAgICBjYXNlICdtb2RlbE1hdHJpeCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnVEYXRhW2tleV0sIGZhbHNlLCBtb2RlbE1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndmlld01hdHJpeCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnVEYXRhW2tleV0sIGZhbHNlLCBjYW1lcmEudmlld01hdHJpeCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncHJvak1hdHJpeCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybU1hdHJpeDRmdih0aGlzLnVEYXRhW2tleV0sIGZhbHNlLCBjYW1lcmEucHJvak1hdHJpeCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndVNhbXBsZXInOlxuICAgICAgICAgICAgICAgICAgICAvLyDQo9C60LDQt9GL0LLQsNC10Lwg0YjQtdC50LTQtdGA0YMsINGH0YLQviDQvNGLINGB0LLRj9C30LDQu9C4INGC0LXQutGB0YLRg9GA0YMg0YEg0YLQtdC60YHRgtGD0YDQvdGL0Lwg0YDQtdCz0LjRgdGC0YDQvtC8IDBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMWkodGhpcy51RGF0YVtrZXldLCAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2X2NvbG9yJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtNGZ2KHRoaXMudURhdGFba2V5XSwgcnVsZXMubWF0ZXJpYWwuZGF0YS5jb2xvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gTElHSFQgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgICAgICAgICBjYXNlICd1X2FtYkludGVuc2l0eSc6IFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVEYXRhW2tleV0sIGxpZ2h0LmFtYmllbnQuaW50ZW5zaXR5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1X2FtYkxpZ2h0Q29sb3InOiBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtM2Z2KHRoaXMudURhdGFba2V5XSwgbGlnaHQuYW1iaWVudC5jb2xvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndV9saWdodENvbG9yJzogIC8vIGxpZ2h0IGNvbG9yIFxuICAgICAgICAgICAgICAgIC8vY29uc29sZS5sb2cobGlnaHQuc291cmNlLmNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtM2Z2KHRoaXMudURhdGFba2V5XSwgbGlnaHQuc291cmNlLmNvbG9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1X2ludGVuc2l0eSc6ICAgLy8gbGlnaHQgaW50ZW5zaXR5ICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy51RGF0YVtrZXldLCBsaWdodC5zb3VyY2UuaW50ZW5zaXR5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1X3NwZWN1bGFySW50JzogICAvLyBzcGVjIGludGVuc2l0eSAgXG4gICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhrZXkpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVEYXRhW2tleV0sIGxpZ2h0LnNvdXJjZS5zcGVjdWxhckludCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndV9zcGVjdWxhckNvbG9yJzogLy8gc3BlY3VsYXIgY29sb3IgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTNmdih0aGlzLnVEYXRhW2tleV0sIGxpZ2h0LnNvdXJjZS5zcGVjdWxhckNvbG9yKTsvL1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ludlRyYW5zcE1vZGVsTWF0cml4JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtTWF0cml4NGZ2KHRoaXMudURhdGFba2V5XSwgZmFsc2UsIGludlRyTW9kZWxNYXRyaXgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3VfbGlnaHRXb3JsZFBvc2l0aW9uJzogLy8gcG9zaXRpb24gbGlnaHQgXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudW5pZm9ybTNmdih0aGlzLnVEYXRhW2tleV0sIFtsaWdodC5zb3VyY2UucG9zaXRpb25MaWdodC54LCBsaWdodC5zb3VyY2UucG9zaXRpb25MaWdodC55LCBsaWdodC5zb3VyY2UucG9zaXRpb25MaWdodC56XSk7IC8vWzAsIDAsIDIwMF1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1X3ZpZXdXb3JsZFBvc2l0aW9uJzogLy8gcG9zaXRpb24gdmlldyBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtM2Z2KHRoaXMudURhdGFba2V5XSwgT2JqZWN0LnZhbHVlcyhjYW1lcmEucG9zaXRpb24pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd1X3NoaW5pbmVzcyc6ICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC51bmlmb3JtMWYodGhpcy51RGF0YVtrZXldLCBsaWdodC5zb3VyY2Uuc2hpbmllc3MpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2tfdmVydGV4JzogIFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnVuaWZvcm0xZih0aGlzLnVEYXRhW2tleV0sIGxpZ2h0LnNvdXJjZS5rX3ZlcnRleCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0QXR0cmlidXRlKHJ1bGVzKXtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuYURhdGEpe1xuICAgICAgICAgICAgc3dpdGNoIChrZXkpe1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Ffbm9ybWFsJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcnNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShydWxlcy5nZW9tZXRyeS5jb3JkLm5vcm1hbHMpLHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hRGF0YVtrZXldLCAzLCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7Ly9nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHNjZW5lLm9iamVjdHNbaV0ucHJvZ1J1bGVzLmF0ckxvY1trZXkyXSwgYnVmU2V0dFtrXSwgZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFEYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FfcG9zaXRpb24nOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHJ1bGVzLmdlb21ldHJ5LmNvcmQudmVydGV4KSx0aGlzLmdsLlNUQVRJQ19EUkFXKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcnNba2V5XSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFEYXRhW2tleV0sIDMsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTsvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2NlbmUub2JqZWN0c1tpXS5wcm9nUnVsZXMuYXRyTG9jW2tleTJdLCBidWZTZXR0W2tdLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYURhdGFba2V5XSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgLy8gY2FzZSAnYV9jb2xvcic6XG4gICAgICAgICAgICAgICAgLy8gICAgIC8vY29uc29sZS5sb2cobWF0ZXJpYWwpO1xuICAgICAgICAgICAgICAgIC8vICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyc1trZXldKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KCksdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG4gICAgXG4gICAgICAgICAgICAgICAgLy8gICAgIC8vdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcnNba2V5XSk7XG4gICAgICAgICAgICAgICAgLy8gICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFEYXRhW2tleV0sIDQsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFEYXRhW2tleV0pO1xuICAgICAgICAgICAgICAgIC8vIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FUZXh0dXJlQ29vcmQnOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXh0QXRyVXBkdCl7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyc1trZXldKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShydWxlcy5nZW9tZXRyeS5jb3JkLm1hcCksdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZFRleHR1cmUodGhpcy5nbC5URVhUVVJFXzJELCBydWxlcy5tYXRlcmlhbC50ZXh0dXJlKTsvL3J1bGVzLm1hdGVyaWFsLnRleHR1cmVcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINC30LDQtNCw0ZHQvCDQv9Cw0YDQsNC80LXRgtGA0YssINGH0YLQvtCx0Ysg0LzQvtC20L3QviDQsdGL0LvQviDQvtGC0YDQuNGB0L7QstCw0YLRjCDQuNC30L7QsdGA0LDQttC10L3QuNC1INC70Y7QsdC+0LPQviDRgNCw0LfQvNC10YDQsFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC50ZXhQYXJhbWV0ZXJpKHRoaXMuZ2wuVEVYVFVSRV8yRCwgdGhpcy5nbC5URVhUVVJFX1dSQVBfUywgdGhpcy5nbC5DTEFNUF9UT19FREdFKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUlOX0ZJTFRFUiwgdGhpcy5nbC5ORUFSRVNUKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NQUdfRklMVEVSLCB0aGlzLmdsLk5FQVJFU1QpO1xuICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG51bSA9IDI7ICAgICAgICAgICAgICAvLyDQutCw0LbQtNCw0Y8g0LrQvtC+0YDQtNC40L3QsNGC0LAg0YHQvtGB0YLQvtC40YIg0LjQtyAyINC30L3QsNGH0LXQvdC40LlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gdGhpcy5nbC5GTE9BVDsgLy8g0LTQsNC90L3Ri9C1INCyINCx0YPRhNC10YDQtSDQuNC80LXRjtGCINGC0LjQvyAzMiBiaXQgZmxvYXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub3JtYWxpemUgPSBmYWxzZTsgICAgLy8g0L3QtSDQvdC+0YDQvNCw0LvQuNC30YPQtdC8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3RyaWRlID0gMDsgICAgICAgICAgIC8vINGB0LrQvtC70YzQutC+INCx0LDQudGCINC80LXQttC00YMg0L7QtNC90LjQvCDQvdCw0LHQvtGA0L7QvCDQtNCw0L3QvdGL0YUg0Lgg0YHQu9C10LTRg9GO0YnQuNC8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgb2Zmc2V0ID0gMDsgICAgICAgICAgIC8vINGB0YLQsNGA0YLQvtCy0LDRjyDQv9C+0LfQuNGG0LjRjyDQsiDQsdCw0LnRgtCw0YUg0LLQvdGD0YLRgNC4INC90LDQsdC+0YDQsCDQtNCw0L3QvdGL0YVcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJzW2tleV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYURhdGFba2V5XSwgbnVtLCB0eXBlLCBub3JtYWxpemUsIHN0cmlkZSwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hRGF0YVtrZXldKTtcbiAgICBcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vINC30LDQs9GA0YPQttCw0LXQvCDQuNC30L7QsdGA0LDQttC10L3QuNC1INCyINGC0LXQutGB0YLRg9GA0YNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHJ1bGVzLm1hdGVyaWFsLmRhdGEubWFwKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZygnYScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy9sZXQgdGV4dHVyZSA9IHRoaXMuZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLmFjdGl2ZVRleHR1cmUodGhpcy5nbC5URVhUVVJFMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRUZXh0dXJlKHRoaXMuZ2wuVEVYVFVSRV8yRCwgcnVsZXMubWF0ZXJpYWwudGV4dHVyZSk7Ly9ydWxlcy5tYXRlcmlhbC50ZXh0dXJlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy50ZXh0QXRyVXBkdCA9IGZhbHNlO1xuICBcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gdXBkYXRlQXR0cmlidXRlKHJ1bGVzKXtcbiAgICAvLyAgICAgZm9yIChsZXQga2V5IGluIHRoaXMuYURhdGEpe1xuICAgIC8vICAgICAgICAgc3dpdGNoIChrZXkpe1xuICAgIC8vICAgICAgICAgICAgIGNhc2UgJ2Ffbm9ybWFsJzpcbiAgICAvLyAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJzW2tleV0pO1xuICAgIC8vICAgICAgICAgICAgICAgICAgdGhpcy5nbC5idWZmZXJEYXRhKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCBuZXcgRmxvYXQzMkFycmF5KHJ1bGVzLmdlb21ldHJ5LmNvcmQubm9ybWFscyksdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJzW2tleV0pO1xuICAgIC8vICAgICAgICAgICAgICAgICAgdGhpcy5nbC52ZXJ0ZXhBdHRyaWJQb2ludGVyKHRoaXMuYURhdGFba2V5XSwgMywgdGhpcy5nbC5GTE9BVCwgZmFsc2UsIDAsIDApOy8vZ2wudmVydGV4QXR0cmliUG9pbnRlcihzY2VuZS5vYmplY3RzW2ldLnByb2dSdWxlcy5hdHJMb2Nba2V5Ml0sIGJ1ZlNldHRba10sIGdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgLy8gICAgICAgICAgICAgICAgICB0aGlzLmdsLmVuYWJsZVZlcnRleEF0dHJpYkFycmF5KHRoaXMuYURhdGFba2V5XSk7XG4gICAgLy8gICAgICAgICAgICAgYnJlYWs7XG4gICAgLy8gICAgICAgICAgICAgY2FzZSAnYV9wb3NpdGlvbic6XG4gICAgLy8gICAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyc1trZXldKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShydWxlcy5nZW9tZXRyeS5jb3JkLnZlcnRleCksdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG4gICAgXG4gICAgLy8gICAgICAgICAgICAgICAgICB0aGlzLmdsLmJpbmRCdWZmZXIodGhpcy5nbC5BUlJBWV9CVUZGRVIsIHRoaXMuYnVmZmVyc1trZXldKTtcbiAgICAvLyAgICAgICAgICAgICAgICAgIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFEYXRhW2tleV0sIDMsIHRoaXMuZ2wuRkxPQVQsIGZhbHNlLCAwLCAwKTsvL2dsLnZlcnRleEF0dHJpYlBvaW50ZXIoc2NlbmUub2JqZWN0c1tpXS5wcm9nUnVsZXMuYXRyTG9jW2tleTJdLCBidWZTZXR0W2tdLCBnbC5GTE9BVCwgZmFsc2UsIDAsIDApO1xuICAgIC8vICAgICAgICAgICAgICAgICAgdGhpcy5nbC5lbmFibGVWZXJ0ZXhBdHRyaWJBcnJheSh0aGlzLmFEYXRhW2tleV0pO1xuICAgIC8vICAgICAgICAgICAgIGJyZWFrO1xuICAgIC8vICAgICAgICAgICAgIC8vIGNhc2UgJ2FfY29sb3InOlxuICAgIC8vICAgICAgICAgICAgIC8vICAgICAvL2NvbnNvbGUubG9nKG1hdGVyaWFsKTtcbiAgICAvLyAgICAgICAgICAgICAvLyAgICAgdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcnNba2V5XSk7XG4gICAgLy8gICAgICAgICAgICAgLy8gICAgIHRoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheSgpLHRoaXMuZ2wuU1RBVElDX0RSQVcpO1xuICAgIFxuICAgIC8vICAgICAgICAgICAgIC8vICAgICAvL3RoaXMuZ2wuYmluZEJ1ZmZlcih0aGlzLmdsLkFSUkFZX0JVRkZFUiwgdGhpcy5idWZmZXJzW2tleV0pO1xuICAgIC8vICAgICAgICAgICAgIC8vICAgICB0aGlzLmdsLnZlcnRleEF0dHJpYlBvaW50ZXIodGhpcy5hRGF0YVtrZXldLCA0LCB0aGlzLmdsLkZMT0FULCBmYWxzZSwgMCwgMCk7XG4gICAgLy8gICAgICAgICAgICAgLy8gICAgIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hRGF0YVtrZXldKTtcbiAgICAvLyAgICAgICAgICAgICAvLyBicmVhaztcbiAgICAvLyAgICAgICAgICAgICBjYXNlICdhVGV4dHVyZUNvb3JkJzpcbiAgICAvLyAgICAgICAgICAgICAgICAgIC8vdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcnNba2V5XSk7XG4gICAgLy8gICAgICAgICAgICAgICAgICAvL3RoaXMuZ2wuYnVmZmVyRGF0YSh0aGlzLmdsLkFSUkFZX0JVRkZFUiwgbmV3IEZsb2F0MzJBcnJheShydWxlcy5nZW9tZXRyeS5jb3JkLm1hcCksdGhpcy5nbC5TVEFUSUNfRFJBVyk7XG5cbiAgICAvLyAgICAgICAgICAgICAgICAgIC8vdGhpcy5nbC5iaW5kVGV4dHVyZSh0aGlzLmdsLlRFWFRVUkVfMkQsIHJ1bGVzLm1hdGVyaWFsLnRleHR1cmUpO1xuXG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIC8v0LfQsNC00LDRkdC8INC/0LDRgNCw0LzQtdGC0YDRiywg0YfRgtC+0LHRiyDQvNC+0LbQvdC+INCx0YvQu9C+INC+0YLRgNC40YHQvtCy0LDRgtGMINC40LfQvtCx0YDQsNC20LXQvdC40LUg0LvRjtCx0L7Qs9C+INGA0LDQt9C80LXRgNCwXG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1MsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9XUkFQX1QsIHRoaXMuZ2wuQ0xBTVBfVE9fRURHRSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRoaXMuZ2wudGV4UGFyYW1ldGVyaSh0aGlzLmdsLlRFWFRVUkVfMkQsIHRoaXMuZ2wuVEVYVFVSRV9NSU5fRklMVEVSLCB0aGlzLmdsLk5FQVJFU1QpO1xuICAgIC8vICAgICAgICAgICAgICAgICAvLyB0aGlzLmdsLnRleFBhcmFtZXRlcmkodGhpcy5nbC5URVhUVVJFXzJELCB0aGlzLmdsLlRFWFRVUkVfTUFHX0ZJTFRFUiwgdGhpcy5nbC5ORUFSRVNUKTtcblxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgbnVtID0gMjsgICAgICAgICAgICAgIC8vINC60LDQttC00LDRjyDQutC+0L7RgNC00LjQvdCw0YLQsCDRgdC+0YHRgtC+0LjRgiDQuNC3IDIg0LfQvdCw0YfQtdC90LjQuVxuICAgIC8vICAgICAgICAgICAgICAgICAgICAgLy8gY29uc3QgdHlwZSA9IHRoaXMuZ2wuRkxPQVQ7IC8vINC00LDQvdC90YvQtSDQsiDQsdGD0YTQtdGA0LUg0LjQvNC10Y7RgiDRgtC40L8gMzIgYml0IGZsb2F0XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBub3JtYWxpemUgPSBmYWxzZTsgICAgLy8g0L3QtSDQvdC+0YDQvNCw0LvQuNC30YPQtdC8XG4gICAgLy8gICAgICAgICAgICAgICAgICAgICAvLyBjb25zdCBzdHJpZGUgPSAwOyAgICAgICAgICAgLy8g0YHQutC+0LvRjNC60L4g0LHQsNC50YIg0LzQtdC20LTRgyDQvtC00L3QuNC8INC90LDQsdC+0YDQvtC8INC00LDQvdC90YvRhSDQuCDRgdC70LXQtNGD0Y7RidC40LxcbiAgICAvLyAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnN0IG9mZnNldCA9IDA7ICAgICAgICAgICAvLyDRgdGC0LDRgNGC0L7QstCw0Y8g0L/QvtC30LjRhtC40Y8g0LIg0LHQsNC50YLQsNGFINCy0L3Rg9GC0YDQuCDQvdCw0LHQvtGA0LAg0LTQsNC90L3Ri9GFXG4gICAgLy8gICAgICAgICAgICAgICAgIC8vdGhpcy5nbC5iaW5kQnVmZmVyKHRoaXMuZ2wuQVJSQVlfQlVGRkVSLCB0aGlzLmJ1ZmZlcnNba2V5XSk7XG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRoaXMuZ2wudmVydGV4QXR0cmliUG9pbnRlcih0aGlzLmFEYXRhW2tleV0sIG51bSwgdHlwZSwgbm9ybWFsaXplLCBzdHJpZGUsIG9mZnNldCk7XG4gICAgLy8gICAgICAgICAgICAgICAgIC8vIHRoaXMuZ2wuZW5hYmxlVmVydGV4QXR0cmliQXJyYXkodGhpcy5hRGF0YVtrZXldKTtcblxuICAgIC8vICAgICAgICAgICAgICAgICAvLyAvLyDQt9Cw0LPRgNGD0LbQsNC10Lwg0LjQt9C+0LHRgNCw0LbQtdC90LjQtSDQsiDRgtC10LrRgdGC0YPRgNGDXG4gICAgLy8gICAgICAgICAgICAgICAgICAvL3RoaXMuZ2wudGV4SW1hZ2UyRCh0aGlzLmdsLlRFWFRVUkVfMkQsIDAsIHRoaXMuZ2wuUkdCQSwgdGhpcy5nbC5SR0JBLCB0aGlzLmdsLlVOU0lHTkVEX0JZVEUsIHJ1bGVzLm1hdGVyaWFsLmRhdGEubWFwKTtcbiAgICAvLyAgICAgICAgICAgICBicmVhaztcbiAgICAvLyAgICAgICAgIH07XG4gICAgLy8gICAgIH1cbiAgICAvLyB9XG4gICAgZ2V0QXRyTG9jYXRpb25zKGdsLHByb2dyYW0sYXRyTmFtZXMpe1xuICAgICAgICBsZXQgYXRyTG9jID0ge307XG4gICAgICAgIGZvciAobGV0IGk9MDtpPGF0ck5hbWVzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgYXRyTG9jW2F0ck5hbWVzW2ldXSA9IGdsLmdldEF0dHJpYkxvY2F0aW9uKHByb2dyYW0sYXRyTmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYURhdGEgPSBhdHJMb2M7XG4gICAgfVxuICAgIGdldFVuaWZMb2NhdGlvbnMoZ2wscHJvZ3JhbSx1bmlmTmFtZXMpe1xuICAgICAgICBsZXQgdW5pZkxvYyA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpPTA7aTx1bmlmTmFtZXMubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICB1bmlmTG9jW3VuaWZOYW1lc1tpXV0gPSBnbC5nZXRVbmlmb3JtTG9jYXRpb24ocHJvZ3JhbSx1bmlmTmFtZXNbaV0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudURhdGEgPSB1bmlmTG9jO1xuICAgIH1cbn1cbmV4cG9ydCB7IFByb2dyYW1SdWxlcyB9OyIsImltcG9ydCB7IFByb2dyYW1SdWxlcyB9IGZyb20gXCIuL1Byb2dyYW1SdWxlc1wiO1xuXG5jbGFzcyBXZWJHbFByb2dyYW1zIHtcbiAgICBjb25zdHJ1Y3RvcihnbCl7XG4gICAgICAgIHRoaXMuZ2wgPSBnbDtcbiAgICB9XG4gICAgY29tcGlsZVByKHNoYWRlcnNDb2RlKXtcbiAgICAgICAgbGV0IGF0cmlidXRlcyA9IFtdO1xuICAgICAgICBsZXQgdW5pZm9ybXMgPSBbXTtcbiAgICAgICAgbGV0IHByb2dyYW0gPSB0aGlzLmNyZWF0ZVByb2dyYW0oc2hhZGVyc0NvZGUudmVydGV4LHNoYWRlcnNDb2RlLmZyYWdtZW50KTtcblxuICAgICAgICBjb25zdCBudW1BdHRyaWJzID0gdGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuQUNUSVZFX0FUVFJJQlVURVMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1BdHRyaWJzOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhdHJpYnV0ZXNbaV09dGhpcy5nbC5nZXRBY3RpdmVBdHRyaWIocHJvZ3JhbSwgaSkubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY29uc3QgbnVtVW5pZm9ybXMgPSB0aGlzLmdsLmdldFByb2dyYW1QYXJhbWV0ZXIocHJvZ3JhbSwgdGhpcy5nbC5BQ1RJVkVfVU5JRk9STVMpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1Vbmlmb3JtczsgKytpKSB7XG4gICAgICAgICAgICAgICAgdW5pZm9ybXNbaV09dGhpcy5nbC5nZXRBY3RpdmVVbmlmb3JtKHByb2dyYW0sIGkpLm5hbWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuICBuZXcgUHJvZ3JhbVJ1bGVzKHRoaXMuZ2wscHJvZ3JhbSxhdHJpYnV0ZXMsdW5pZm9ybXMpO1xuICAgIH1cbiAgICBjcmVhdGVTaGFkZXJzKHR5cGUsc291cmNlKXtcbiAgICAgICAgbGV0IHNoYWRlciA9IHRoaXMuZ2wuY3JlYXRlU2hhZGVyKHR5cGUpOyBcbiAgICAgICAgdGhpcy5nbC5zaGFkZXJTb3VyY2Uoc2hhZGVyLCBzb3VyY2UpOyAgICAgIFxuICAgICAgICB0aGlzLmdsLmNvbXBpbGVTaGFkZXIoc2hhZGVyKTsgICAgICAgICAgICBcbiAgICAgICAgaWYgKHRoaXMuZ2wuZ2V0U2hhZGVyUGFyYW1ldGVyKHNoYWRlciwgdGhpcy5nbC5DT01QSUxFX1NUQVRVUykpeyAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgcmV0dXJuIHNoYWRlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuZ2wuZ2V0U2hhZGVySW5mb0xvZyhzaGFkZXIpKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlU2hhZGVyKHNoYWRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUHJvZ3JhbSh2ZXJ0ZXgsZnJhZ21lbnQpe1xuXG4gICAgICAgIGxldCBwcm9ncmFtID0gdGhpcy5nbC5jcmVhdGVQcm9ncmFtKCk7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHRoaXMuY3JlYXRlU2hhZGVycyh0aGlzLmdsLlZFUlRFWF9TSEFERVIsdmVydGV4KSk7XG4gICAgICAgIHRoaXMuZ2wuYXR0YWNoU2hhZGVyKHByb2dyYW0sIHRoaXMuY3JlYXRlU2hhZGVycyh0aGlzLmdsLkZSQUdNRU5UX1NIQURFUixmcmFnbWVudCkpO1xuICAgICAgICB0aGlzLmdsLmxpbmtQcm9ncmFtKHByb2dyYW0pO1xuICAgICAgICBpZiAodGhpcy5nbC5nZXRQcm9ncmFtUGFyYW1ldGVyKHByb2dyYW0sIHRoaXMuZ2wuTElOS19TVEFUVVMpKXtcbiAgICAgICAgICByZXR1cm4gcHJvZ3JhbTsgXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyh0aGlzLmdsLmdldFByb2dyYW1JbmZvTG9nKHByb2dyYW0pKTtcbiAgICAgICAgICAgIHRoaXMuZ2wuZGVsZXRlUHJvZ3JhbShwcm9ncmFtKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydCB7IFdlYkdsUHJvZ3JhbXMgfTtcblxuXG4vKlxuXG4gICAgICAgIGlmICgoY2FtZXJhID09PSB1bmRlZmluZWQpJihtZXNoLm1hdGVyaWFsID09PSB1bmRlZmluZWQpKXtcbiAgICAgICAgICAgIHZlcnRleCA9IGBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuXG4gICAgICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHVuZF9jb2xvcjtcblxuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBtb2RlbE1hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbi54eXosMS4wKTsgXG4gICAgICAgICAgICAgICAgICAgIHVuZF9jb2xvciA9IGdsX1Bvc2l0aW9uICogMC41ICsgMC41O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGA7XG4gICAgICAgICAgICBmcmFnbWVudCA9IGBcbiAgICAgICAgICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICAgICAgICAgIHZhcnlpbmcgdmVjNCB1bmRfY29sb3I7XG5cbiAgICAgICAgICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHVuZF9jb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgYXRyTmFtZXMgPSBbJ2FfcG9zaXRpb24nXTtcbiAgICAgICAgICAgIHVuaWZvcm1WYXJOYW1lcyA9Wydtb2RlbE1hdHJpeCddO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKChjYW1lcmEgPT09IHVuZGVmaW5lZCkmKG1lc2gubWF0ZXJpYWwgIT09IHVuZGVmaW5lZCkpe1xuICAgICAgICAgICAgdmVydGV4ID0gYFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlIHZlYzQgYV9jb2xvcjtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcbiAgICAgICAgXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLnh5eiwxLjApO1xuICAgICAgICAgICAgICAgICAgICB2X2NvbG9yID0gYV9jb2xvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBtZXNoLm1hdGVyaWFsLmdldEZyYWdtZW50Q29kZSgpO1xuICAgICAgICAgICAgYXRyTmFtZXMgPSBbJ2FfcG9zaXRpb24nLCdhX2NvbG9yJ107XG4gICAgICAgICAgICB1bmlmb3JtVmFyTmFtZXMgPVsnbW9kZWxNYXRyaXgnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2FtZXJhICE9PSB1bmRlZmluZWQpJihtZXNoLm1hdGVyaWFsID09PSB1bmRlZmluZWQpKXtcbiAgICAgICAgICAgIHZlcnRleCA9IGBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuXG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xuICAgICAgICAgICAgICAgIHVuaWZvcm0gbWF0NCBwcm9qTWF0cml4O1xuXG4gICAgICAgICAgICAgICAgdmFyeWluZyB2ZWM0IHVuZF9jb2xvcjtcblxuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLnh5eiwxLjApO1xuICAgICAgICAgICAgICAgICAgICB1bmRfY29sb3IgPSBnbF9Qb3NpdGlvbiAqIDAuNSArIDAuNTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBgO1xuICAgICAgICAgICAgZnJhZ21lbnQgPSBgXG4gICAgICAgICAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdW5kX2NvbG9yO1xuXG4gICAgICAgICAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB1bmRfY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIGF0ck5hbWVzID0gWydhX3Bvc2l0aW9uJ107XG4gICAgICAgICAgICB1bmlmb3JtVmFyTmFtZXMgPSBbJ21vZGVsTWF0cml4Jywndmlld01hdHJpeCcsJ3Byb2pNYXRyaXgnXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoY2FtZXJhICE9PSB1bmRlZmluZWQpJihtZXNoLm1hdGVyaWFsICE9PSB1bmRlZmluZWQpKXtcbiAgICAgICAgICAgIHZlcnRleCA9IGBcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZSB2ZWM0IGFfY29sb3I7XG5cbiAgICAgICAgICAgICAgICB1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XG4gICAgICAgICAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XG5cbiAgICAgICAgICAgICAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcblxuICAgICAgICAgICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLnh5eiwxLjApOyBcbiAgICAgICAgICAgICAgICAgICAgdl9jb2xvciA9IGFfY29sb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgYDtcbiAgICAgICAgICAgIGZyYWdtZW50ID0gbWVzaC5tYXRlcmlhbC5nZXRGcmFnbWVudENvZGUoKTtcbiAgICAgICAgICAgIGF0ck5hbWVzID0gWydhX3Bvc2l0aW9uJywnYV9jb2xvciddO1xuICAgICAgICAgICAgdW5pZm9ybVZhck5hbWVzID0gWydtb2RlbE1hdHJpeCcsJ3ZpZXdNYXRyaXgnLCdwcm9qTWF0cml4J107XG4gICAgICAgIH1cbiovIiwiaW1wb3J0IHsgV2ViR2xQcm9ncmFtcyB9IGZyb20gXCIuLi9wcm9ncmFtL1dlYkdsUHJvZ3JhbXNcIjtcblxuY2xhc3MgQ29yZU1hdGVyaWFsIHtcbiAgICBjb25zdHJ1Y3RvciAoZGF0YSl7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtYXRlcmlhbCc7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHRoaXMuc3RydWN0ID0ge1xuICAgICAgICAgICAgY29sb3I6ICh0aGlzLmRhdGEuY29sb3IhPT11bmRlZmluZWQpLFxuICAgICAgICAgICAgbWFwOiAodGhpcy5kYXRhLm1hcCE9PXVuZGVmaW5lZCksXG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU2hhZGVyc0NvZGUoY29kZSl7XG4gICAgICAgIC8vbGV0IGRhdGEgPSBPYmplY3QuZW50cmllcyh0aGlzLmRhdGEpO1xuICAgICAgICBpZiAoISh0aGlzLnN0cnVjdC5jb2xvcnx8dGhpcy5zdHJ1Y3QubWFwKSl7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0FkZCBtYXRlcmlhbCEgQ29sb3Igb3IvYW5kIG1hcCBsaWtlIHtjb2xvcjpbMC4wLDAuMCwwLjAsMS4wXX0nKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RydWN0LmNvbG9yICYgIXRoaXMuc3RydWN0Lm1hcCl7XG4gICAgICAgICAgICAgICAgdGhpcy5zaGFkZXJzQ29kZSA9IGNvZGUuY29sb3I7XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5zdHJ1Y3QuY29sb3IgJiB0aGlzLnN0cnVjdC5tYXApe1xuICAgICAgICAgICAgICAgIHRoaXMuc2hhZGVyc0NvZGUgPSBjb2RlLm1hcDtcbiAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuc3RydWN0LmNvbG9yICYgdGhpcy5zdHJ1Y3QubWFwKXtcbiAgICAgICAgICAgICAgICB0aGlzLnNoYWRlcnNDb2RlID0gY29kZS5tYXBBbmRDb2xvcjtcbiAgICAgICAgICB9XG4gICAgfVxuICAgIGdldFByb2dyYW0oZ2wpeyBcbiAgICAgICAgcmV0dXJuIG5ldyBXZWJHbFByb2dyYW1zKGdsKS5jb21waWxlUHIodGhpcy5zaGFkZXJzQ29kZSk7XG4gICAgfVxuICAgIG1ha2VXZWJHbERlcGVuZGVuc2VGY24oZ2wpe1xuICAgICAgICBpZiAodGhpcy5zdHJ1Y3QubWFwKSB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wpO1xuICAgIH1cbiAgICBjcmVhdGVUZXh0dXJlKGdsKXtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ29yZU1hdGVyaWFsIH0iLCJpbXBvcnQgeyBDb3JlTWF0ZXJpYWwgfSBmcm9tIFwiLi9Db3JlTWF0ZXJpYWxcIjtcblxuY29uc3Qgc2hhZGVyc0Jhc2ljTWF0ZXJpYWwgPSB7XG4gICAgY29sb3I6e1xuICAgICAgICB2ZXJ0ZXg6IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICBcbiAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XG4gICAgXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvak1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbi54eXosMS4wKTsgLy9cbiAgICAgICAgfVxuICAgIGAsXG4gICAgICAgIGZyYWdtZW50OiBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIFxuICAgICAgICB1bmlmb3JtIHZlYzQgdl9jb2xvcjtcbiAgICBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdl9jb2xvcjtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgfSxcbiAgICBtYXA6e1xuICAgICAgICB2ZXJ0ZXg6IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBcbiAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XG4gICAgXG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24ueHl6LDEuMCk7IC8vXG4gICAgICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgICAgIGZyYWdtZW50OiBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIFxuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG4gICAgXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgIH1cbiAgICBgLFxuICAgIH0sXG4gICAgbWFwQW5kQ29sb3I6e1xuICAgICAgICB2ZXJ0ZXg6IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICBcbiAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XG4gICAgXG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24ueHl6LDEuMCk7IC8vXG4gICAgICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgICAgIGZyYWdtZW50OiBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuICAgICAgICB1bmlmb3JtIHZlYzQgdl9jb2xvcjtcblxuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcblxuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBoaWdocCB2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdGV4ZWxDb2xvciAqIHZfY29sb3I7XG4gICAgICAgIH1cbiAgICBgLFxuICAgIH1cbn07XG5cbmNsYXNzIEJhc2ljTWF0ZXJpYWwgZXh0ZW5kcyBDb3JlTWF0ZXJpYWx7XG4gICAgY29uc3RydWN0b3IoZGF0YSl7XG4gICAgICAgIHN1cGVyKGRhdGEpO1xuICAgICAgICB0aGlzLmNyZWF0ZVNoYWRlcnNDb2RlKHNoYWRlcnNCYXNpY01hdGVyaWFsKTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJhc2ljTWF0ZXJpYWwgfTsiLCJpbXBvcnQgeyBDb29yZGluYXRlczNEIH0gZnJvbSBcIi4uL0Nvb3JkaW5hdGVzM0RcIjtcbmltcG9ydCB7IE1hdHJpeCB9IGZyb20gXCIuLi9tYXRoL01hdHJpeFwiO1xuXG5jbGFzcyBDYW1lcmF7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBDb29yZGluYXRlczNEKCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgQ29vcmRpbmF0ZXMzRCgpOyBcbiAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBDb29yZGluYXRlczNEKDEsMSwxKTtcbiAgICAgICAgdGhpcy5vcnRvZ3JhcGhpY1NldHQgPSB7XG4gICAgICAgICAgICByaWdodDogMCxcbiAgICAgICAgICAgIGxlZnQ6IDAsXG4gICAgICAgICAgICB0b3A6IDAsIFxuICAgICAgICAgICAgYm90dG9tOiAwLCBcbiAgICAgICAgICAgIGZhcjogMCxcbiAgICAgICAgICAgIG5lYXI6IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVTZXR0ID0ge1xuICAgICAgICAgICAgek5lYXI6IDAuNSxcbiAgICAgICAgICAgIHpGYXI6IDAsXG4gICAgICAgICAgICBmb3Y6IDYwLFxuICAgICAgICAgICAgYXNwZWN0OjAsXG4gICAgICAgIH07XG4gICAgfVxuICAgIHVwZGF0ZUNhbWVyYU10cngoKXtcbiAgICAgICAgdGhpcy52aWV3TWF0cml4ID0gbmV3IE1hdHJpeCgpLmludmVydE1vZGVsTWF0cml4KHRoaXMucG9zaXRpb24sdGhpcy5zY2FsZSx0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5vcnRvZ3JhcGhpY01hdHJpeCA9IG5ldyBNYXRyaXgoKS5vcnRvZ3JhcGhpYyh0aGlzLm9ydG9ncmFwaGljU2V0dCk7XG4gICAgICAgIHRoaXMucGVyc3BlY3RpdmVNYXRyaXggPSBuZXcgTWF0cml4KCkucGVyc3BlY3RpdmUodGhpcy5wZXJzcGVjdGl2ZVNldHQpO1xuICAgICAgICB0aGlzLnByb2pNYXRyaXggPSB0aGlzLnBlcnNwZWN0aXZlTWF0cml4O1xuICAgIH1cbn1cblxuZXhwb3J0IHsgQ2FtZXJhIH07IiwiaW1wb3J0IHsgQ29vcmRpbmF0ZXMzRCB9IGZyb20gXCIuL0Nvb3JkaW5hdGVzM0RcIjtcbmltcG9ydCB7IEJhc2ljTWF0ZXJpYWwgfSBmcm9tIFwiLi9tYXRlcmlhbC9CYXNpY01hdGVyaWFsXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9tYXRoL01hdHJpeFwiO1xuXG5jbGFzcyBNZXNoIHtcbiAgICBjb25zdHJ1Y3RvcihnZW9tZXRyeSxtYXRlcmlhbCl7XG4gICAgICAgIHRoaXMudHlwZSA9ICdtZXNoJztcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBDb29yZGluYXRlczNEKCk7XG4gICAgICAgIHRoaXMucm90YXRpb24gPSBuZXcgQ29vcmRpbmF0ZXMzRCgpOyBcbiAgICAgICAgdGhpcy5zY2FsZSA9IG5ldyBDb29yZGluYXRlczNEKDEsMSwxKTtcbiAgICAgICAgdGhpcy5kYWZhdWx0TWF0ZXJpYWwgPSBuZXcgQmFzaWNNYXRlcmlhbCAoe2NvbG9yOiBbMS4wLCAxLjAsIDEuMCwgMS4wXX0pO1xuICAgICAgICB0aGlzLmNyZWF0ZURpc3BsYXlSdWxlcyhnZW9tZXRyeS5nZXRHZW9tZXRyeSgpLG1hdGVyaWFsKTtcbiAgICAgICAgXG4gICAgfVxuICAgIGNyZWF0ZVByb2dyYW1SdWxlcyhnbCl7XG4gICAgICAgIGZvciAobGV0IGs9MDtrPHRoaXMuZGlzcGxheVJ1bGVzLmxlbmd0aDtrKyspe1xuICAgICAgICAgICAgdGhpcy5kaXNwbGF5UnVsZXNba10ubWF0ZXJpYWwucHJvZ1J1bGVzID0gdGhpcy5kaXNwbGF5UnVsZXNba10ubWF0ZXJpYWwuZ2V0UHJvZ3JhbShnbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZG9Qcm9ncmFtKGdsLGNhbWVyYSxsaWdodCl7XG4gICAgICAgIGZvciAobGV0IGs9MDtrPHRoaXMuZGlzcGxheVJ1bGVzLmxlbmd0aDtrKyspe1xuICAgICAgICAgICAgZ2wudXNlUHJvZ3JhbSh0aGlzLmRpc3BsYXlSdWxlc1trXS5tYXRlcmlhbC5wcm9nUnVsZXMucHJvZ3JhbSk7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlSdWxlc1trXS5tYXRlcmlhbC5wcm9nUnVsZXMuc2V0VW5pZm9ybShcbiAgICAgICAgICAgICAgICB0aGlzLm1vZGVsTWF0cml4LFxuICAgICAgICAgICAgICAgIHRoaXMuaW52VHJhbnNwTW9kZWxNYXRyaXgsXG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwbGF5UnVsZXNba10sXG4gICAgICAgICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgICAgICAgIGxpZ2h0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BsYXlSdWxlc1trXS5tYXRlcmlhbC5wcm9nUnVsZXMuc2V0QXR0cmlidXRlKHRoaXMuZGlzcGxheVJ1bGVzW2tdKTtcbiAgICAgICAgICAgIGdsLmRyYXdBcnJheXMoZ2wuVFJJQU5HTEVTLCAwLCB0aGlzLmRpc3BsYXlSdWxlc1trXS5nZW9tZXRyeS5pbmZvLm51bVZlcnRleCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kb25lU2VuZEF0dHJpYnV0ZSAgPSBmYWxzZTtcbiAgICB9XG4gICAgY3JlYXRlRGlzcGxheVJ1bGVzKGdlb21ldHJ5LG1hdGVyaWFsKXtcbiAgICAgICAgbGV0IHJ1bGVzID0gW107XG4gICAgICAgIGxldCBuZXdNYXRlcmlhbCA9IHRoaXMuY3JlYXRlTWF0ZXJpYWwoZ2VvbWV0cnksbWF0ZXJpYWwpO1xuICAgICAgICBmb3IgKGxldCBpPTA7aTxnZW9tZXRyeS5wYXJ0cy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgIGlmICh0aGlzLm1vbm9DaHJvbWUpe1xuICAgICAgICAgICAgICAgIHJ1bGVzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbDogbmV3TWF0ZXJpYWwsXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeS5wYXJ0c1tpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJ1bGVzW2ldID0ge1xuICAgICAgICAgICAgICAgICAgICBtYXRlcmlhbDogbmV3TWF0ZXJpYWxbaV0sXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnZW9tZXRyeS5wYXJ0c1tpXVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kaXNwbGF5UnVsZXMgPSBydWxlcztcbiAgICB9XG4gICAgY3JlYXRlTWF0ZXJpYWwoZ2VvbWV0cnksbWF0ZXJpYWwpe1xuICAgICAgICBsZXQgbmV3TWF0ZXJpYWwgPSBbXTtcbiAgICAgICAgbGV0IGlzTWF0ZXJpYWxBcnJheSA9IEFycmF5LmlzQXJyYXkobWF0ZXJpYWwpO1xuICAgICAgICB0aGlzLm1vbm9DaHJvbWUgPSAhaXNNYXRlcmlhbEFycmF5O1xuICAgICAgICBpZiAoaXNNYXRlcmlhbEFycmF5KXtcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDtpPGdlb21ldHJ5LnBhcnRzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgICAgIGlmKG1hdGVyaWFsW2ldIT09dW5kZWZpbmVkKXtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0ZXJpYWxbaV09bWF0ZXJpYWxbaV07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3TWF0ZXJpYWxbaV0gPSB0aGlzLmRhZmF1bHRNYXRlcmlhbDtcbiAgICAgICAgICAgICAgICB9IFxuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgbmV3TWF0ZXJpYWwgPSBtYXRlcmlhbDtcblxuICAgICAgICByZXR1cm4gbmV3TWF0ZXJpYWw7XG4gICAgfVxuICAgIHVwZGF0ZU1lc2hNYXRyaXgoKXsgXG4gICAgICAgIHRoaXMubW9kZWxNYXRyaXggPSBuZXcgTWF0cml4KCkubXVsdGlwbHlUb01vZGVsKHRoaXMucG9zaXRpb24sdGhpcy5zY2FsZSx0aGlzLnJvdGF0aW9uKTtcbiAgICAgICAgdGhpcy5pbnZUcmFuc3BNb2RlbE1hdHJpeCA9IG5ldyBNYXRyaXgoKS5pbnZlcnQobmV3IE1hdHJpeCgpLnRyYW5zcG9zZSh0aGlzLm1vZGVsTWF0cml4KSk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBNZXNoIH07XG5cbiIsIlxuY2xhc3MgQ29yZUdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICB0aGlzLnBhcnRzR2VvbWV0cnkgPSBbXTtcbiAgICB9XG4gICAgY3JlYXRlR2VvbWV0cnkgKHR5cGUsY29yZFZlcnRleCxjb3JkTWFwLGNvcmROb3JtYWxzKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IHR5cGUsXG4gICAgICAgICAgICBjb3JkOntcbiAgICAgICAgICAgICAgICB2ZXJ0ZXg6IGNvcmRWZXJ0ZXgsXG4gICAgICAgICAgICAgICAgbWFwOiBjb3JkTWFwLFxuICAgICAgICAgICAgICAgIG5vcm1hbHM6IGNvcmROb3JtYWxzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW5mbzp7XG4gICAgICAgICAgICAgICAgbnVtVmVydGV4OiBjb3JkVmVydGV4Lmxlbmd0aC8zLFxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVTb2xpZEdlb21ldHJ5KCl7XG4gICAgICAgIGxldCB2ZXJ0ZXhDb3JkID0gW107XG4gICAgICAgIGxldCBtYXBDb3JkID0gW107XG4gICAgICAgIGxldCBub3JtYWxzID0gW107XG4gICAgICAgIGxldCBudW1WZXJ0ZXggPSAwO1xuICAgICAgICBmb3IgKGxldCBpPTA7aTx0aGlzLnBhcnRzR2VvbWV0cnkubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICB2ZXJ0ZXhDb3JkID0gdmVydGV4Q29yZC5jb25jYXQodGhpcy5wYXJ0c0dlb21ldHJ5W2ldLmNvcmQudmVydGV4KTtcbiAgICAgICAgICAgIG1hcENvcmQgPSBtYXBDb3JkLmNvbmNhdCh0aGlzLnBhcnRzR2VvbWV0cnlbaV0uY29yZC5tYXApO1xuICAgICAgICAgICAgbm9ybWFscyA9IG1hcENvcmQuY29uY2F0KHRoaXMucGFydHNHZW9tZXRyeVtpXS5jb3JkLm5vcm1hbHMpO1xuICAgICAgICAgICAgbnVtVmVydGV4ICs9IHRoaXMucGFydHNHZW9tZXRyeVtpXS5pbmZvLm51bVZlcnRleDtcbiAgICAgICAgfSBcbiAgICAgICAgdGhpcy5zb2xpZEdlb21ldHJ5ID0gdGhpcy5jcmVhdGVHZW9tZXRyeSgnc29saWQnLHZlcnRleENvcmQsbWFwQ29yZCxub3JtYWxzLG51bVZlcnRleCk7XG4gICAgICAgIHRoaXMuc29saWRHZW9tZXRyeS5pbmZvLm51bVBhcnRzID0gdGhpcy5wYXJ0c0dlb21ldHJ5Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29saWRHZW9tZXRyeTtcbiAgICB9XG4gICAgZ2V0R2VvbWV0cnkoKXtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhcnRzOiB0aGlzLmNyZWF0ZVZlcnRleCgpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICBjcmVhdGVWZXJ0ZXgoKXt9XG59XG5cbmV4cG9ydCB7IENvcmVHZW9tZXRyeSB9OyIsIlxuaW1wb3J0IHsgQ29vcmRpbmF0ZXMzRCB9IGZyb20gXCIuLi9Db29yZGluYXRlczNEXCI7XG5pbXBvcnQgeyBDb3JlR2VvbWV0cnkgfSBmcm9tIFwiLi9Db3JlR2VvbWV0cnlcIjtcblxuY2xhc3MgUmVjdGFuZ3VsYXJHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IodyxoLHgseSx6KXtcbiAgICAgIHRoaXMuc3RhcnQgPSBuZXcgQ29vcmRpbmF0ZXMzRCh4LHkseik7XG4gICAgICB0aGlzLncgPSB3O1xuICAgICAgdGhpcy5oID0gaDtcbiAgICAgIHRoaXMuY3JlYXRlVmVydGV4KCk7XG4gICAgfVxuICAgIGNyZWF0ZVZlcnRleCgpe1xuICAgICAgICBsZXQgeDAgPSB0aGlzLnN0YXJ0Lng7XG4gICAgICAgIGxldCB4MSA9IHgwKyB0aGlzLnc7XG4gICAgICAgIGxldCB5MCA9IHRoaXMuc3RhcnQueTtcbiAgICAgICAgbGV0IHkxID0geTArdGhpcy5oOyBcbiAgICAgICAgbGV0IHowID0gdGhpcy5zdGFydC56O1xuXG4gICAgICAgIGxldCB2ZXJ0ZXggPSAgW1xuICAgICAgICAgICAgeDAseTAsejAsXG4gICAgICAgICAgICB4MSx5MCx6MCxcbiAgICAgICAgICAgIHgwLHkxLHowLFxuICAgICAgXG4gICAgICAgICAgICB4MCx5MSx6MCxcbiAgICAgICAgICAgIHgxLHkwLHowLFxuICAgICAgICAgICAgeDEseTEsejAsXG4gICAgICAgIF07XG4gICAgICAgIHRoaXMuY29yZCA9IHZlcnRleDtcbiAgICAgICAgdGhpcy5udW1WZXJ0ZXggPSB2ZXJ0ZXgubGVuZ3RoIC8gMztcbiAgICAgICAgLy90aGlzLm9mZnNldEJ5dGVzID0gdmVydGV4Lmxlbmd0aCAqIDQ7XG4gICAgICAgIHRoaXMubnVtRmFjZXMgPSAxO1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBSZWN0YW5ndWxhckdlb21ldHJ5IH07XG4iLCJpbXBvcnQgeyBDb29yZGluYXRlczNEIH0gZnJvbSBcIi4vQ29vcmRpbmF0ZXMzRFwiO1xuXG5jbGFzcyBTY2VuZSB7XG4gICAgY29uc3RydWN0b3IoKXtcbiAgICAgICAgdGhpcy5tZXNocyA9IFtdO1xuICAgICAgICB0aGlzLmxpZ2h0cyA9IFtdO1xuICAgICAgICB0aGlzLmJhY2tncm91bmQgPSBbMC4wLCAwLjAsIDAuMCwgMS4wXTtcbiAgICAgICAgdGhpcy5uZWVkVXBkYXRlID0gZmFsc2U7XG4gICAgfVxuICAgIGNyZWF0ZUxpZ2h0UnVsZXMgKCl7XG5cbiAgICAgICAgbGV0IHJ1bGVzID0ge307XG4gICAgICAgIGZvciAobGV0IGk9MDtpPHRoaXMubGlnaHRzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgaWYgKHRoaXMubGlnaHRzW2ldLnR5cGVMaWdodD09J2FtYmllbnQnKXtcbiAgICAgICAgICAgICAgICBydWxlcy5hbWJpZW50ID0gdGhpcy5saWdodHNbaV0uY3JlYXRlRGF0YVRvV2ViZ2woKTtcbiAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICBydWxlcy5zb3VyY2UgPSB0aGlzLmxpZ2h0c1tpXS5jcmVhdGVEYXRhVG9XZWJnbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChydWxlc1snYW1iaWVudCddID09IHVuZGVmaW5lZCl7XG4gICAgICAgICAgICBydWxlc1snYW1iaWVudCddID0ge1xuICAgICAgICAgICAgICAgIGNvbG9yOiBbMC4wLDAuMCwwLjBdLFxuICAgICAgICAgICAgICAgIGludGVuc2l0eTogMC4wLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSBcbiAgICAgICAgaWYgKHJ1bGVzWydzb3VyY2UnXSA9PSB1bmRlZmluZWQpe1xuICAgICAgICAgICAgcnVsZXNbJ3NvdXJjZSddPSB7XG4gICAgICAgICAgICAgICAgY29sb3I6IFswLjAsMC4wLDAuMF0sXG4gICAgICAgICAgICAgICAgaW50ZW5zaXR5OiAwLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uTGlnaHQ6IG5ldyBDb29yZGluYXRlczNEKCksXG4gICAgICAgICAgICAgICAgc2hpbmllc3M6IDAuMCxcbiAgICAgICAgICAgICAgICBzcGVjdWxhckNvbG9yOiBbMC4wLDAuMCwwLjBdLFxuICAgICAgICAgICAgICAgIHNwZWN1bGFySW50OiAwLjAsXG4gICAgICAgICAgICAgICAga192ZXJ0ZXg6IDEuMCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5saWdodFJ1bGVzID0gcnVsZXM7XG4gICAgICAgIC8vY29uc29sZS5sb2cocnVsZXMpO1xuICAgIH1cbiAgICBhZGQob2JqZWN0KXtcbiAgICAgICAgaWYgKG9iamVjdC50eXBlID09ICdtZXNoJyl7XG4gICAgICAgICAgICB0aGlzLm1lc2hzID0gdGhpcy5tZXNocy5jb25jYXQob2JqZWN0KTtcbiAgICAgICAgfSBlbHNlIGlmIChvYmplY3QudHlwZSA9PSAnbGlnaHQnKSB7XG4gICAgICAgICAgICB0aGlzLmxpZ2h0cyA9IHRoaXMubGlnaHRzLmNvbmNhdChvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmVlZFVwZGF0ZSA9IHRydWU7XG4gICAgfVxuICAgIHVwZGF0ZShnbCl7XG4gICAgICAgIGlmICh0aGlzLm5lZWRVcGRhdGUpeyBcbiAgICAgICAgICAgIGZvciAobGV0IGk9MDtpPHRoaXMubWVzaHMubGVuZ3RoO2krKyl7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaz0wO2s8dGhpcy5tZXNoc1tpXS5kaXNwbGF5UnVsZXMubGVuZ3RoO2srKyl7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWVzaHNbaV0uY3JlYXRlUHJvZ3JhbVJ1bGVzKGdsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5tZXNoc1tpXS5kaXNwbGF5UnVsZXNba10ubWF0ZXJpYWwubWFrZVdlYkdsRGVwZW5kZW5zZUZjbihnbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMubWVzaHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMubGlnaHRzLmxlbmd0aD4wKXtcbiAgICAgICAgICAgICAgICB0aGlzLmNyZWF0ZUxpZ2h0UnVsZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMubGlnaHRSdWxlcyk7XG4gICAgICAgICAgICB0aGlzLm5lZWRVcGRhdGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpPTA7aTx0aGlzLm1lc2hzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgdGhpcy5tZXNoc1tpXS51cGRhdGVNZXNoTWF0cml4KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXNlUHJvZ3JhbShnbCxjYW1lcmEpe1xuICAgICAgICBmb3IgKGxldCBpPTA7aTx0aGlzLm1lc2hzLmxlbmd0aDtpKyspe1xuICAgICAgICAgICAgdGhpcy5tZXNoc1tpXS5kb1Byb2dyYW0oZ2wsY2FtZXJhLHRoaXMubGlnaHRSdWxlcyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IFNjZW5lIH07IiwiXG5pbXBvcnQgeyBDb29yZGluYXRlczNEIH0gZnJvbSBcIi4uL0Nvb3JkaW5hdGVzM0RcIjtcblxuY2xhc3MgVHJpYW5nbGVHZW9tZXRyeSB7XG4gICAgY29uc3RydWN0b3IodyxoLHgseSx6KXtcbiAgICAgIHRoaXMuc3RhcnQgPSBuZXcgQ29vcmRpbmF0ZXMzRCh4LHkseik7XG4gICAgICBcbiAgICAgIHRoaXMudyA9IHc7XG4gICAgICB0aGlzLmggPSBoO1xuICAgICAgdGhpcy5jcmVhdGVWZXJ0ZXgoKTtcbiAgICB9XG4gICAgY3JlYXRlVmVydGV4KCl7XG4gICAgICAgIGxldCB4MCA9IHRoaXMuc3RhcnQueDtcbiAgICAgICAgbGV0IHkwID0gdGhpcy5zdGFydC55O1xuICAgICAgICBsZXQgejAgPSB0aGlzLnN0YXJ0Lno7XG5cbiAgICAgICAgbGV0IHgxID0geDAgKyB0aGlzLnc7XG4gICAgICAgIGxldCB4MiA9IHgwIC0gdGhpcy53O1xuICAgICAgICBsZXQgeTEgPSB5MCArIHRoaXMuaDsgXG5cbiAgICAgICAgbGV0IHZlcnRleCA9ICBbXG4gICAgICAgICAgICB4MCx5MCx6MCxcbiAgICAgICAgICAgIHgyLHkxLHowLFxuICAgICAgICAgICAgeDEseTEsejBcbiAgICAgICAgXTtcbiAgICAgICAgdGhpcy5jb3JkID0gdmVydGV4O1xuICAgICAgICB0aGlzLm51bVZlcnRleCA9IHZlcnRleC5sZW5ndGggLyAzO1xuICAgICAgICB0aGlzLm51bVBvaW50cyA9IDM7XG4gICAgICAgIHRoaXMub2Zmc2V0Qnl0ZXMgPSB2ZXJ0ZXgubGVuZ3RoICogNDtcbiAgICAgICAgdGhpcy5udW1FZGdlcyA9IDE7XG4gICAgfVxufVxuXG5leHBvcnQgeyBUcmlhbmdsZUdlb21ldHJ5IH07IiwiXG5jbGFzcyBXZWJHbFJlbmRlciB7XG4gICAgY29uc3RydWN0b3IgKGNhbnZhcyl7XG4gICAgICAgIHRoaXMuY2FudmFzID0gY2FudmFzO1xuICAgICAgICB0aGlzLmdldENvbnRleHQoKTtcbiAgICB9XG4gICAgcmVuZGVyKHNjZW5lLGNhbWVyYSl7XG4gICAgICAgIHRoaXMuY2xlYXJTY3JlZW4oc2NlbmUuYmFja2dyb3VuZCk7XG4gICAgICAgIHRoaXMudXBkYXRlKHNjZW5lLGNhbWVyYSk7XG4gICAgICAgIHRoaXMuZHJhdyhzY2VuZSxjYW1lcmEpO1xuICAgIH1cbiAgICB1cGRhdGUoc2NlbmUsY2FtZXJhKXtcbiAgICAgICAgc2NlbmUudXBkYXRlKHRoaXMuZ2wpO1xuICAgICAgICBjYW1lcmEudXBkYXRlQ2FtZXJhTXRyeCgpO1xuICAgIH1cbiAgICBkcmF3KHNjZW5lLGNhbWVyYSl7XG4gICAgICAgIHNjZW5lLnVzZVByb2dyYW0odGhpcy5nbCxjYW1lcmEpO1xuICAgIH1cbiAgICBjbGVhclNjcmVlbihiYWNrZ3JvdW5kKXtcbiAgICAgICAgdGhpcy5nbC52aWV3cG9ydCgwLCAwLCB0aGlzLmNhbnZhcy53aWR0aCwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5nbC5jbGVhckNvbG9yKGJhY2tncm91bmRbMF0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kWzFdLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZFsyXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRbM10pOyAgLy8gQ2xlYXIgdG8gYmxhY2ssIGZ1bGx5IG9wYXF1ZSAvLygwLjAsIDAuMCwgMC4wLCAxLjApXG4gICAgICAgIHRoaXMuZ2wuY2xlYXJEZXB0aCgxLjApOyAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgZXZlcnl0aGluZ1xuICAgICAgICB0aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkRFUFRIX1RFU1QpOyAgICAgICAgICAgLy8gRW5hYmxlIGRlcHRoIHRlc3RpbmdcbiAgICAgICAgLy90aGlzLmdsLmVuYWJsZSh0aGlzLmdsLkNVTExfRkFDRSk7XG4gICAgICAgIHRoaXMuZ2wuZGVwdGhGdW5jKHRoaXMuZ2wuTEVRVUFMKTsgICAgICAgICAgICAvLyBOZWFyIHRoaW5ncyBvYnNjdXJlIGZhciB0aGluZ3NcbiAgICAgICAgdGhpcy5nbC5jbGVhcih0aGlzLmdsLkNPTE9SX0JVRkZFUl9CSVQgfCB0aGlzLmdsLkRFUFRIX0JVRkZFUl9CSVQpO1xuICAgIH1cbiAgICBnZXRDb250ZXh0KCl7XG4gICAgICAgIHRoaXMuZ2wgPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KCd3ZWJnbCcpO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgV2ViR2xSZW5kZXIgfTsiLCJpbXBvcnQgeyBDb29yZGluYXRlczNEIH0gZnJvbSBcIi4uL0Nvb3JkaW5hdGVzM0RcIjtcbmltcG9ydCB7IENvcmVHZW9tZXRyeSB9IGZyb20gXCIuL0NvcmVHZW9tZXRyeVwiO1xuaW1wb3J0IHsgUmVjdGFuZ3VsYXJHZW9tZXRyeSB9IGZyb20gXCIuL1JlY3Rhbmd1bGFyR2VvbWV0cnlcIjtcblxuY2xhc3MgQm94R2VvbWV0cnkgZXh0ZW5kcyBDb3JlR2VvbWV0cnl7XG4gICAgY29uc3RydWN0b3IgKHcsaCxkLHgseSx6KXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgdGhpcy5oID0gaDtcbiAgICAgICAgdGhpcy5kID0gZDtcbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBDb29yZGluYXRlczNEKHgseSx6KTtcbiAgICAgICAgLy90aGlzLmNyZWF0ZVZlcnRleCgpO1xuICAgIH1cbiAgICBjcmVhdGVWZXJ0ZXgoKXtcbiAgICAgICAgbGV0IHZlcnRleCA9IFtdO1xuICAgICAgICBsZXQgZnJvbnRSZWN0ID0gbmV3IFJlY3Rhbmd1bGFyR2VvbWV0cnkodGhpcy53LHRoaXMuaCx0aGlzLnN0YXJ0LngsdGhpcy5zdGFydC55LHRoaXMuZC8yKTtcbiAgICAgICAgbGV0IGJhY2tSZWN0ID0gbmV3IFJlY3Rhbmd1bGFyR2VvbWV0cnkodGhpcy53LHRoaXMuaCx0aGlzLnN0YXJ0LngsdGhpcy5zdGFydC55LC0odGhpcy5kLzIpKTtcblxuLy8tLS0tLS0tLS0tLS0tLS0gVE9QIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGxldCB0b3BYMCA9IGZyb250UmVjdC5jb3JkWzBdO1xuICAgICAgICBsZXQgdG9wWTAgPSBmcm9udFJlY3QuY29yZFsxXTtcbiAgICAgICAgbGV0IHRvcFowID0gZnJvbnRSZWN0LmNvcmRbMl07XG5cbiAgICAgICAgbGV0IHRvcFgxID0gZnJvbnRSZWN0LmNvcmRbM107XG4gICAgICAgIGxldCB0b3BZMSA9IGZyb250UmVjdC5jb3JkWzRdO1xuICAgICAgICBsZXQgdG9wWjEgPSBmcm9udFJlY3QuY29yZFs1XTsgIFxuXG4gICAgICAgIGxldCB0b3BYMiA9IGJhY2tSZWN0LmNvcmRbMF07XG4gICAgICAgIGxldCB0b3BZMiA9IGJhY2tSZWN0LmNvcmRbMV07XG4gICAgICAgIGxldCB0b3BaMiA9IGJhY2tSZWN0LmNvcmRbMl07XG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgbGV0IHRvcFgzID0gYmFja1JlY3QuY29yZFszXTtcbiAgICAgICAgbGV0IHRvcFkzID0gYmFja1JlY3QuY29yZFs0XTtcbiAgICAgICAgbGV0IHRvcFozID0gYmFja1JlY3QuY29yZFs1XTtcblxuICAgICAgICBsZXQgdG9wVmVydGV4ID0gIFtcbiAgICAgICAgICAgIHRvcFgwLHRvcFkwLHRvcFowLFxuICAgICAgICAgICAgdG9wWDEsdG9wWTEsdG9wWjEsXG4gICAgICAgICAgICB0b3BYMix0b3BZMix0b3BaMixcbiAgICAgIFxuICAgICAgICAgICAgdG9wWDIsdG9wWTIsdG9wWjIsXG4gICAgICAgICAgICB0b3BYMSx0b3BZMSx0b3BaMSxcbiAgICAgICAgICAgIHRvcFgzLHRvcFkzLHRvcFozLFxuICAgICAgICBdO1xuLy8tLS0tLS0tLS0tLS0tLS0gQm90dG9tIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGxldCBib3R0b21YMCA9IGZyb250UmVjdC5jb3JkWzldO1xuICAgICAgICBsZXQgYm90dG9tWTAgPSBmcm9udFJlY3QuY29yZFsxMF07XG4gICAgICAgIGxldCBib3R0b21aMCA9IGZyb250UmVjdC5jb3JkWzExXTtcblxuICAgICAgICBsZXQgYm90dG9tWDEgPSBmcm9udFJlY3QuY29yZFsxNV07XG4gICAgICAgIGxldCBib3R0b21ZMSA9IGZyb250UmVjdC5jb3JkWzE2XTtcbiAgICAgICAgbGV0IGJvdHRvbVoxID0gZnJvbnRSZWN0LmNvcmRbMTddOyAgXG5cbiAgICAgICAgbGV0IGJvdHRvbVgyID0gYmFja1JlY3QuY29yZFs5XTtcbiAgICAgICAgbGV0IGJvdHRvbVkyID0gYmFja1JlY3QuY29yZFsxMF07XG4gICAgICAgIGxldCBib3R0b21aMiA9IGJhY2tSZWN0LmNvcmRbMTFdO1xuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgICAgIGxldCBib3R0b21YMyA9IGJhY2tSZWN0LmNvcmRbMTVdO1xuICAgICAgICBsZXQgYm90dG9tWTMgPSBiYWNrUmVjdC5jb3JkWzE2XTtcbiAgICAgICAgbGV0IGJvdHRvbVozID0gYmFja1JlY3QuY29yZFsxN107XG5cbiAgICAgICAgbGV0IGJvdHRvbVZlcnRleCA9ICBbXG4gICAgICAgICAgICBib3R0b21YMCxib3R0b21ZMCxib3R0b21aMCxcbiAgICAgICAgICAgIGJvdHRvbVgxLGJvdHRvbVkxLGJvdHRvbVoxLFxuICAgICAgICAgICAgYm90dG9tWDIsYm90dG9tWTIsYm90dG9tWjIsXG5cbiAgICAgICAgICAgIGJvdHRvbVgyLGJvdHRvbVkyLGJvdHRvbVoyLFxuICAgICAgICAgICAgYm90dG9tWDEsYm90dG9tWTEsYm90dG9tWjEsXG4gICAgICAgICAgICBib3R0b21YMyxib3R0b21ZMyxib3R0b21aMyxcbiAgICAgICAgXTtcbiAgICAgICAgbGV0IGxlZnRWZXJ0ZXggPSAgW1xuICAgICAgICAgICAgdG9wWDAsdG9wWTAsdG9wWjAsXG4gICAgICAgICAgICB0b3BYMix0b3BZMix0b3BaMixcbiAgICAgICAgICAgIGJvdHRvbVgwLGJvdHRvbVkwLGJvdHRvbVowLFxuXG4gICAgICAgICAgICBib3R0b21YMCxib3R0b21ZMCxib3R0b21aMCxcbiAgICAgICAgICAgIHRvcFgyLHRvcFkyLHRvcFoyLFxuICAgICAgICAgICAgYm90dG9tWDIsYm90dG9tWTIsYm90dG9tWjIsXG4gICAgICAgIF07XG4gICAgICAgIGxldCByaWdodFZlcnRleCA9ICBbXG4gICAgICAgICAgICB0b3BYMSx0b3BZMSx0b3BaMSxcbiAgICAgICAgICAgIHRvcFgzLHRvcFkzLHRvcFozLFxuICAgICAgICAgICAgYm90dG9tWDEsYm90dG9tWTEsYm90dG9tWjEsXG5cbiAgICAgICAgICAgIGJvdHRvbVgxLGJvdHRvbVkxLGJvdHRvbVoxLFxuICAgICAgICAgICAgdG9wWDMsdG9wWTMsdG9wWjMsXG4gICAgICAgICAgICBib3R0b21YMyxib3R0b21ZMyxib3R0b21aMyxcbiAgICAgICAgXTtcblxuICAgICAgICBjb25zdCBtYXBDb3JkMkQgPSBbXG4gICAgICAgICAgICAwLjAsICAwLjAsXG4gICAgICAgICAgICAxLjAsICAwLjAsXG4gICAgICAgICAgICAwLjAsICAxLjAsXG4gICAgICAgICAgICAwLjAsICAxLjAsXG4gICAgICAgICAgICAxLjAsICAwLjAsXG4gICAgICAgICAgICAxLjAsICAxLjAgXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGZyb250Tm9ybWFscyA9IFtcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgIDEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgIDEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgIDEuMCxcblxuICAgICAgICAgICAgMC4wLCAgMC4wLCAgMS4wLFxuICAgICAgICAgICAgMC4wLCAgMC4wLCAgMS4wLFxuICAgICAgICAgICAgMC4wLCAgMC4wLCAgMS4wLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBiYWNrTm9ybWFscyA9IFtcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgLTEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgLTEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgLTEuMCxcblxuICAgICAgICAgICAgMC4wLCAgMC4wLCAtMS4wLFxuICAgICAgICAgICAgMC4wLCAgMC4wLCAtMS4wLFxuICAgICAgICAgICAgMC4wLCAgMC4wLCAtMS4wLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCB0b3BOb3JtYWxzID0gW1xuICAgICAgICAgICAgMC4wLCAgLTEuMCwgIDAuMCxcbiAgICAgICAgICAgIDAuMCwgIC0xLjAsICAwLjAsXG4gICAgICAgICAgICAwLjAsICAtMS4wLCAgMC4wLFxuXG4gICAgICAgICAgICAwLjAsICAtMS4wLCAgMC4wLFxuICAgICAgICAgICAgMC4wLCAgLTEuMCwgIDAuMCxcbiAgICAgICAgICAgIDAuMCwgIC0xLjAsICAwLjAsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGJvdHRvbU5vcm1hbHMgPSBbXG4gICAgICAgICAgICAwLjAsIDEuMCwgIDAuMCxcbiAgICAgICAgICAgIDAuMCwgMS4wLCAgMC4wLFxuICAgICAgICAgICAgMC4wLCAxLjAsICAwLjAsXG5cbiAgICAgICAgICAgIDAuMCwgMS4wLCAgMC4wLFxuICAgICAgICAgICAgMC4wLCAxLjAsICAwLjAsXG4gICAgICAgICAgICAwLjAsIDEuMCwgIDAuMCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbGVmdE5vcm1hbHMgPSBbXG4gICAgICAgICAgICAtMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgLTEuMCwgIDAuMCwgIDAuMCxcbiAgICAgICAgICAgIC0xLjAsICAwLjAsICAwLjAsXG5cbiAgICAgICAgICAgIC0xLjAsICAwLjAsICAwLjAsXG4gICAgICAgICAgICAtMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgLTEuMCwgIDAuMCwgIDAuMCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgcmlnaHROb3JtYWxzID0gW1xuICAgICAgICAgICAgMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLCAgMC4wLFxuXG4gICAgICAgICAgICAxLjAsICAwLjAsICAwLjAsXG4gICAgICAgICAgICAxLjAsICAwLjAsICAwLjAsXG4gICAgICAgICAgICAxLjAsICAwLjAsICAwLjAsXG4gICAgICAgIF07XG5cbiAgICAgICAgdGhpcy5wYXJ0c0dlb21ldHJ5ID0gW1xuICAgICAgICAgICAgdGhpcy5jcmVhdGVHZW9tZXRyeSgncGFydCcsZnJvbnRSZWN0LmNvcmQsbWFwQ29yZDJELGZyb250Tm9ybWFscyksXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdlb21ldHJ5KCdwYXJ0JyxiYWNrUmVjdC5jb3JkLG1hcENvcmQyRCxiYWNrTm9ybWFscyksXG4gICAgICAgICAgICB0aGlzLmNyZWF0ZUdlb21ldHJ5KCdwYXJ0Jyx0b3BWZXJ0ZXgsbWFwQ29yZDJELHRvcE5vcm1hbHMpLFxuICAgICAgICAgICAgdGhpcy5jcmVhdGVHZW9tZXRyeSgncGFydCcsYm90dG9tVmVydGV4LG1hcENvcmQyRCxib3R0b21Ob3JtYWxzKSxcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR2VvbWV0cnkoJ3BhcnQnLGxlZnRWZXJ0ZXgsbWFwQ29yZDJELGxlZnROb3JtYWxzKSxcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR2VvbWV0cnkoJ3BhcnQnLHJpZ2h0VmVydGV4LG1hcENvcmQyRCxyaWdodE5vcm1hbHMpLFxuICAgICAgICBdO1xuXG4gICAgICAgIC8vdmVydGV4ID0gdmVydGV4LmNvbmNhdChmcm9udFJlY3QuY29yZCxiYWNrUmVjdC5jb3JkLHRvcFZlcnRleCxib3R0b21WZXJ0ZXgsbGVmdFZlcnRleCxyaWdodFZlcnRleCk7XG4gICAgICAgIHJldHVybiB0aGlzLnBhcnRzR2VvbWV0cnk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBCb3hHZW9tZXRyeSB9OyIsImltcG9ydCB7IFdlYkdsUHJvZ3JhbXMgfSBmcm9tIFwiLi4vcHJvZ3JhbS9XZWJHbFByb2dyYW1zXCI7XG5cbmNsYXNzIE1hdGVyaWFsIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlKXtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5uZWVkVXBkYXRlID0gdHJ1ZTtcbiAgICB9XG4gICAgZ2V0UHJvZ3JhbShnbCl7XG4gICAgICAgIHJldHVybiBuZXcgV2ViR2xQcm9ncmFtcyhnbCkuY29tcGlsZVByKHRoaXMudmVydGV4LHRoaXMuZnJhZ21lbnQpO1xuICAgIH1cbiAgICB1cGRhdGUoKXt9XG4gICAgbWFrZVdlYkdsRGVwZW5kZW5zZUZjbigpe31cbn1cbmV4cG9ydCB7IE1hdGVyaWFsIH07IiwiaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tIFwiLi9NYXRlcmlhbFwiO1xuXG5jb25zdCB2ZXJ0ZXhUZXh0dXJlTWF0ZXJpYWwgPSBgXG4gICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuXG4gICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xuICAgIHVuaWZvcm0gbWF0NCBwcm9qTWF0cml4O1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX1Bvc2l0aW9uID0gcHJvak1hdHJpeCAqIHZpZXdNYXRyaXggKiBtb2RlbE1hdHJpeCAqIHZlYzQoYV9wb3NpdGlvbi54eXosMS4wKTsgLy9cbiAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgfVxuYDtcbmNvbnN0IGZyYWdtZW50VGV4dHVyZU1hdGVyaWFsID0gYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbiAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgIGdsX0ZyYWdDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgfVxuYDtcblxuY2xhc3MgVGV4dHVyZU1hdGVyaWFsIGV4dGVuZHMgTWF0ZXJpYWwge1xuICAgIGNvbnN0cnVjdG9yKGltYWdlKXtcbiAgICAgICAgc3VwZXIoJ3RleHR1cmUyRCcpO1xuICAgICAgICB0aGlzLmltYWdlID0gaW1hZ2U7XG4gICAgICAgIHRoaXMudmVydGV4ID0gdmVydGV4VGV4dHVyZU1hdGVyaWFsO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnRUZXh0dXJlTWF0ZXJpYWw7XG4gICAgfVxuICAgIG1ha2VXZWJHbERlcGVuZGVuc2VGY24oZ2wpe1xuICAgICAgICB0aGlzLmNyZWF0ZVRleHR1cmUoZ2wpO1xuICAgIH1cbiAgICBjcmVhdGVUZXh0dXJlKGdsKXtcbiAgICAgICAgdGhpcy50ZXh0dXJlID0gZ2wuY3JlYXRlVGV4dHVyZSgpO1xuICAgIH1cbiAgICB1cGRhdGUoZGF0YUdlb20pe1xuICAgICAgICBsZXQgYXJyID0gW107XG4gICAgICAgIGxldCBjb3JkID0gW1xuICAgICAgICAgICAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLFxuICAgICAgICAgICAgMC4wLCAgMS4wLFxuICAgICAgICAgICAgMC4wLCAgMS4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMS4wIF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpPGRhdGFHZW9tLm51bUVkZ2VzO2krKyl7XG4gICAgICAgICAgICBhcnIgPSBhcnIuY29uY2F0KGNvcmQpO1xuICAgICAgICB9IFxuICAgICAgICB0aGlzLnRleHR1cmVDb3JkID0gYXJyO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgVGV4dHVyZU1hdGVyaWFsIH07IiwiaW1wb3J0IHsgTWF0ZXJpYWwgfSBmcm9tIFwiLi9NYXRlcmlhbFwiO1xuXG5jb25zdCB2ZXJ0ZXhHcmFkaWVudE1hdGVyaWFsID0gYFxuICAgIGF0dHJpYnV0ZSB2ZWMzIGFfcG9zaXRpb247XG5cbiAgICB1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XG4gICAgdW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XG4gICAgdW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XG5cbiAgICB2YXJ5aW5nIHZlYzQgdl9jb2xvcjtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLnh5eiwxLjApOyAvL1xuICAgICAgICB2X2NvbG9yID0gZ2xfUG9zaXRpb24gKiAwLjUgKyAwLjU7XG4gICAgfVxuYDtcbmNvbnN0IGZyYWdtZW50R3JhZGllbnRNYXRlcmlhbCA9IGBcbiAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgIHZhcnlpbmcgdmVjNCB2X2NvbG9yO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xuICAgIH1cbmA7XG5cbmNsYXNzIEdyYWRpZW50TWF0ZXJpYWwgZXh0ZW5kcyBNYXRlcmlhbHtcbiAgICBjb25zdHJ1Y3Rvcigpe1xuICAgICAgICBzdXBlcignZ3JhZGllbnQnKTtcbiAgICAgICAgdGhpcy52ZXJ0ZXggPSB2ZXJ0ZXhHcmFkaWVudE1hdGVyaWFsO1xuICAgICAgICB0aGlzLmZyYWdtZW50ID0gZnJhZ21lbnRHcmFkaWVudE1hdGVyaWFsO1xuICAgIH1cbn1cblxuZXhwb3J0IHsgR3JhZGllbnRNYXRlcmlhbCB9OyIsImltcG9ydCB7IE1hdGVyaWFsIH0gZnJvbSBcIi4vTWF0ZXJpYWxcIjtcblxuY29uc3QgdmVydGV4TW9ub0NvbG9yTWF0ZXJpYWwgPSBgXG4gICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcblxuICAgIHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcbiAgICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcbiAgICB1bmlmb3JtIG1hdDQgcHJvak1hdHJpeDtcblxuICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLnh5eiwxLjApOyAvL1xuICAgIH1cbmA7XG5jb25zdCBmcmFnbWVudE1vbm9Db2xvck1hdGVyaWFsID0gYFxuICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgdW5pZm9ybSB2ZWM0IGNvbG9yO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgICBnbF9GcmFnQ29sb3IgPSBjb2xvcjtcbiAgICB9XG5gO1xuXG5jbGFzcyBNb25vY2hyb21lQ29sb3IgZXh0ZW5kcyBNYXRlcmlhbCB7XG4gICAgY29uc3RydWN0b3IgKGNvbG9yKXtcbiAgICAgICAgc3VwZXIoJ21vbm9Db2xvcicpO1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMudmVydGV4ID0gdmVydGV4TW9ub0NvbG9yTWF0ZXJpYWw7XG4gICAgICAgIHRoaXMuZnJhZ21lbnQgPSBmcmFnbWVudE1vbm9Db2xvck1hdGVyaWFsO1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBNb25vY2hyb21lQ29sb3IgfTsiLCJpbXBvcnQgeyBDb3JlTWF0ZXJpYWwgfSBmcm9tIFwiLi9Db3JlTWF0ZXJpYWxcIjtcblxuY29uc3Qgc2hhZGVyc1Bob25nTWF0ZXJpYWwgPSB7XG4gICAgY29sb3I6e1xuICAgICAgICB2ZXJ0ZXg6IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XG5cbiAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XG5cbiAgICAgICAgdW5pZm9ybSBtYXQ0IGludlRyYW5zcE1vZGVsTWF0cml4O1xuXG4gICAgICAgIHZhcnlpbmcgdmVjMyB3b3JsZF9WZXJ0ZXg7XG4gICAgICAgIHZhcnlpbmcgdmVjMyB3b3JsZF9Ob3JtYWw7XG5cbiAgICBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLnh5eiwxLjApO1xuXG4gICAgICAgICAgICB3b3JsZF9WZXJ0ZXggPSBtYXQzKGludlRyYW5zcE1vZGVsTWF0cml4KSAqIGFfcG9zaXRpb247IFxuICAgICAgICAgICAgd29ybGRfTm9ybWFsID0gbWF0MyhpbnZUcmFuc3BNb2RlbE1hdHJpeCkgKiBhX25vcm1hbDsgXG4gICAgICAgIH1cbiAgICBgLFxuICAgICAgICBmcmFnbWVudDogYFxuICAgICAgICBwcmVjaXNpb24gaGlnaHAgZmxvYXQ7XG4gICAgXG4gICAgICAgIHVuaWZvcm0gdmVjNCB2X2NvbG9yO1xuXG4gICAgICAgIHVuaWZvcm0gZmxvYXQga192ZXJ0ZXg7XG5cbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1X2FtYkludGVuc2l0eTtcbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfYW1iTGlnaHRDb2xvcjtcblxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xuICAgICAgICB1bmlmb3JtIHZlYzMgdV9saWdodENvbG9yO1xuXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdV9zaGluaW5lc3M7XG5cbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfc3BlY3VsYXJDb2xvcjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3NwZWN1bGFySW50O1xuXG4gICAgICAgIHVuaWZvcm0gdmVjMyB1X2xpZ2h0V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfdmlld1dvcmxkUG9zaXRpb247XG5cbiAgICAgICAgdmFyeWluZyB2ZWMzIHdvcmxkX1ZlcnRleDtcbiAgICAgICAgdmFyeWluZyB2ZWMzIHdvcmxkX05vcm1hbDtcblxuICAgICAgICB2ZWMzIGFtYmllbnRfY29sb3I7XG4gICAgICAgIHZlYzMgZGlmZnVzZV9jb2xvcjtcbiAgICAgICAgdmVjMyBzcGVjdWxhcl9jb2xvcjtcblxuICAgICAgICB2ZWMzIGNvbG9yO1xuXG4gICAgICAgIHZvaWQgbWFpbigpIHtcbiAgICAgICAgICAgIGFtYmllbnRfY29sb3IgPSB1X2FtYkxpZ2h0Q29sb3IgKiB1X2FtYkludGVuc2l0eTsgLy8g0YTQvtC90L7QstC+0LUg0L7RgdCy0LXRidC10L3QuNC1IDEg0L3QsCDQstGB0Y4g0YHRhtC10L3Rg1xuXG4gICAgICAgICAgICAgICAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUod29ybGRfTm9ybWFsKTtcbiAgICAgICAgICAgICAgICBmbG9hdCBrID0gY2xhbXAoa192ZXJ0ZXgsIDAuMCwgMS4wKTtcblxuICAgICAgICAgICAgICAgIHZlYzMgdG9fbGlnaHQgPSB1X2xpZ2h0V29ybGRQb3NpdGlvbiAtIGsgKiB3b3JsZF9WZXJ0ZXg7XG4gICAgICAgICAgICAgICAgdG9fbGlnaHQgPSBub3JtYWxpemUodG9fbGlnaHQpO1xuXG4gICAgICAgICAgICAgICAgZmxvYXQgY29zX2FuZ2xlID0gZG90KG5vcm1hbCx0b19saWdodCk7IFxuICAgICAgICAgICAgICAgIGNvc19hbmdsZSA9IGNsYW1wKGNvc19hbmdsZSwgMC4wLCAxLjApO1xuXG4gICAgICAgICAgICBkaWZmdXNlX2NvbG9yID0gY29zX2FuZ2xlICogdV9saWdodENvbG9yICogdV9pbnRlbnNpdHk7ICBcblxuICAgICAgICAgICAgICAgIHZlYzMgdG9fVmlldyA9IHVfdmlld1dvcmxkUG9zaXRpb24gLSAgayAqIHdvcmxkX1ZlcnRleDtcbiAgICAgICAgICAgICAgICB0b19WaWV3ID0gbm9ybWFsaXplKHRvX1ZpZXcpO1xuXG4gICAgICAgICAgICAgICAgdmVjMyBoYWxmVmVjdG9yID0gbm9ybWFsaXplKHRvX1ZpZXcgKyB0b19saWdodCk7XG5cbiAgICAgICAgICAgIHNwZWN1bGFyX2NvbG9yID0gKHBvdyhkb3Qobm9ybWFsLCBoYWxmVmVjdG9yKSwgdV9zaGluaW5lc3MpICogdV9zcGVjdWxhckNvbG9yKSAqIHVfc3BlY3VsYXJJbnQ7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY29sb3IgPSAgYW1iaWVudF9jb2xvcjsgXG4gICAgICAgICAgICBjb2xvciArPSB2X2NvbG9yLnJnYiAqIGRpZmZ1c2VfY29sb3I7XG4gICAgICAgICAgICBjb2xvciArPSBzcGVjdWxhcl9jb2xvcjtcblxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvcix2X2NvbG9yLmEpOy8vdmVjMyhzcGVjdWxhckludCxzcGVjdWxhckludCxzcGVjdWxhckludClcbiAgICAgICAgfVxuICAgIGAsXG4gICAgfSxcbiAgICBtYXA6e1xuICAgICAgICB2ZXJ0ZXg6IGBcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9wb3NpdGlvbjtcbiAgICAgICAgYXR0cmlidXRlIHZlYzIgYVRleHR1cmVDb29yZDtcbiAgICAgICAgYXR0cmlidXRlIHZlYzMgYV9ub3JtYWw7XG4gICAgXG4gICAgICAgIHVuaWZvcm0gbWF0NCBtb2RlbE1hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHZpZXdNYXRyaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0NCBwcm9qTWF0cml4O1xuXG4gICAgICAgIHVuaWZvcm0gbWF0NCBpbnZUcmFuc3BNb2RlbE1hdHJpeDtcbiAgICBcbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbiAgICAgICAgdmFyeWluZyB2ZWMzIHdvcmxkX1ZlcnRleDtcbiAgICAgICAgdmFyeWluZyB2ZWMzIHdvcmxkX05vcm1hbDtcbiAgICBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgZ2xfUG9zaXRpb24gPSBwcm9qTWF0cml4ICogdmlld01hdHJpeCAqIG1vZGVsTWF0cml4ICogdmVjNChhX3Bvc2l0aW9uLnh5eiwxLjApO1xuICAgICAgICAgICAgdlRleHR1cmVDb29yZCA9IGFUZXh0dXJlQ29vcmQ7XG4gICAgICAgICAgICB3b3JsZF9WZXJ0ZXggPSBtYXQzKGludlRyYW5zcE1vZGVsTWF0cml4KSAqIGFfcG9zaXRpb247IFxuICAgICAgICAgICAgd29ybGRfTm9ybWFsID0gbWF0MyhpbnZUcmFuc3BNb2RlbE1hdHJpeCkgKiBhX25vcm1hbDtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgICAgIGZyYWdtZW50OiBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuXG4gICAgICAgIHVuaWZvcm0gc2FtcGxlcjJEIHVTYW1wbGVyO1xuXG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xuXG4gICAgICAgIHVuaWZvcm0gZmxvYXQga192ZXJ0ZXg7XG5cbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1X2FtYkludGVuc2l0eTtcbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfYW1iTGlnaHRDb2xvcjtcblxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVfaW50ZW5zaXR5O1xuICAgICAgICB1bmlmb3JtIHZlYzMgdV9saWdodENvbG9yO1xuXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdV9zaGluaW5lc3M7XG5cbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfc3BlY3VsYXJDb2xvcjtcbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3NwZWN1bGFySW50O1xuXG4gICAgICAgIHVuaWZvcm0gdmVjMyB1X2xpZ2h0V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfdmlld1dvcmxkUG9zaXRpb247XG5cbiAgICAgICAgdmFyeWluZyB2ZWMzIHdvcmxkX1ZlcnRleDtcbiAgICAgICAgdmFyeWluZyB2ZWMzIHdvcmxkX05vcm1hbDtcblxuICAgICAgICB2ZWMzIGFtYmllbnRfY29sb3I7XG4gICAgICAgIHZlYzMgZGlmZnVzZV9jb2xvcjtcbiAgICAgICAgdmVjMyBzcGVjdWxhcl9jb2xvcjtcblxuICAgICAgICB2ZWMzIGNvbG9yO1xuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG5cbiAgICAgICAgICAgIGFtYmllbnRfY29sb3IgPSB1X2FtYkxpZ2h0Q29sb3IgKiB1X2FtYkludGVuc2l0eTsgLy8g0YTQvtC90L7QstC+0LUg0L7RgdCy0LXRidC10L3QuNC1IDEg0L3QsCDQstGB0Y4g0YHRhtC10L3Rg1xuXG4gICAgICAgICAgICAgICAgdmVjMyBub3JtYWwgPSBub3JtYWxpemUod29ybGRfTm9ybWFsKTtcbiAgICAgICAgICAgICAgICBmbG9hdCBrID0gY2xhbXAoa192ZXJ0ZXgsIDAuMCwgMS4wKTtcblxuICAgICAgICAgICAgICAgIHZlYzMgdG9fbGlnaHQgPSB1X2xpZ2h0V29ybGRQb3NpdGlvbiAtIGsgKiB3b3JsZF9WZXJ0ZXg7XG4gICAgICAgICAgICAgICAgdG9fbGlnaHQgPSBub3JtYWxpemUodG9fbGlnaHQpO1xuXG4gICAgICAgICAgICAgICAgZmxvYXQgY29zX2FuZ2xlID0gZG90KG5vcm1hbCx0b19saWdodCk7IFxuICAgICAgICAgICAgICAgIGNvc19hbmdsZSA9IGNsYW1wKGNvc19hbmdsZSwgMC4wLCAxLjApO1xuXG4gICAgICAgICAgICBkaWZmdXNlX2NvbG9yID0gY29zX2FuZ2xlICogdV9saWdodENvbG9yICogdV9pbnRlbnNpdHk7ICBcblxuICAgICAgICAgICAgICAgIHZlYzMgdG9fVmlldyA9IHVfdmlld1dvcmxkUG9zaXRpb24gLSAgayAqIHdvcmxkX1ZlcnRleDtcbiAgICAgICAgICAgICAgICB0b19WaWV3ID0gbm9ybWFsaXplKHRvX1ZpZXcpO1xuXG4gICAgICAgICAgICAgICAgdmVjMyBoYWxmVmVjdG9yID0gbm9ybWFsaXplKHRvX1ZpZXcgKyB0b19saWdodCk7XG5cbiAgICAgICAgICAgIHNwZWN1bGFyX2NvbG9yID0gKHBvdyhkb3Qobm9ybWFsLCBoYWxmVmVjdG9yKSwgdV9zaGluaW5lc3MpICogdV9zcGVjdWxhckNvbG9yKSAqIHVfc3BlY3VsYXJJbnQ7XG5cbiAgICAgICAgICAgIGhpZ2hwIHZlYzQgdGV4ZWxDb2xvciA9IHRleHR1cmUyRCh1U2FtcGxlciwgdlRleHR1cmVDb29yZCk7XG4gICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgY29sb3IgPSBhbWJpZW50X2NvbG9yOyBcbiAgICAgICAgICAgIGNvbG9yICs9IHRleGVsQ29sb3IucmdiICogZGlmZnVzZV9jb2xvcjsgLy8gXG4gICAgICAgICAgICBjb2xvciArPSBzcGVjdWxhcl9jb2xvcjtcblxuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNChjb2xvciwgdGV4ZWxDb2xvci5hKTtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgfSxcbiAgICBtYXBBbmRDb2xvcjp7XG4gICAgICAgIHZlcnRleDogYFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcbiAgICBcbiAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgdmlld01hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHByb2pNYXRyaXg7XG5cbiAgICAgICAgdW5pZm9ybSBtYXQ0IGludlRyYW5zcE1vZGVsTWF0cml4O1xuICAgIFxuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcblxuICAgICAgICB2YXJ5aW5nIHZlYzMgd29ybGRfVmVydGV4O1xuICAgICAgICB2YXJ5aW5nIHZlYzMgd29ybGRfTm9ybWFsO1xuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24ueHl6LDEuMCk7XG4gICAgICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIHdvcmxkX1ZlcnRleCA9IG1hdDMoaW52VHJhbnNwTW9kZWxNYXRyaXgpICogYV9wb3NpdGlvbjsgXG4gICAgICAgICAgICB3b3JsZF9Ob3JtYWwgPSBtYXQzKGludlRyYW5zcE1vZGVsTWF0cml4KSAqIGFfbm9ybWFsO1xuICAgICAgICB9XG4gICAgYCxcbiAgICAgICAgZnJhZ21lbnQ6IGBcbiAgICAgICAgcHJlY2lzaW9uIG1lZGl1bXAgZmxvYXQ7XG5cbiAgICAgICAgdW5pZm9ybSB2ZWM0IHZfY29sb3I7XG5cbiAgICAgICAgdW5pZm9ybSBzYW1wbGVyMkQgdVNhbXBsZXI7XG5cbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG5cbiAgICAgICAgdW5pZm9ybSBmbG9hdCBrX3ZlcnRleDtcblxuICAgICAgICB1bmlmb3JtIGZsb2F0IHVfYW1iSW50ZW5zaXR5O1xuICAgICAgICB1bmlmb3JtIHZlYzMgdV9hbWJMaWdodENvbG9yO1xuXG4gICAgICAgIHVuaWZvcm0gZmxvYXQgdV9pbnRlbnNpdHk7XG4gICAgICAgIHVuaWZvcm0gdmVjMyB1X2xpZ2h0Q29sb3I7XG5cbiAgICAgICAgdW5pZm9ybSBmbG9hdCB1X3NoaW5pbmVzcztcblxuICAgICAgICB1bmlmb3JtIHZlYzMgdV9zcGVjdWxhckNvbG9yO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHVfc3BlY3VsYXJJbnQ7XG5cbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfbGlnaHRXb3JsZFBvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIHZlYzMgdV92aWV3V29ybGRQb3NpdGlvbjtcblxuICAgICAgICB2YXJ5aW5nIHZlYzMgd29ybGRfVmVydGV4O1xuICAgICAgICB2YXJ5aW5nIHZlYzMgd29ybGRfTm9ybWFsO1xuXG4gICAgICAgIHZlYzMgYW1iaWVudF9jb2xvcjtcbiAgICAgICAgdmVjMyBkaWZmdXNlX2NvbG9yO1xuICAgICAgICB2ZWMzIHNwZWN1bGFyX2NvbG9yO1xuXG4gICAgICAgIHZlYzMgY29sb3I7XG4gICAgXG4gICAgICAgIHZvaWQgbWFpbigpIHtcblxuICAgICAgICAgICAgYW1iaWVudF9jb2xvciA9IHVfYW1iTGlnaHRDb2xvciAqIHVfYW1iSW50ZW5zaXR5OyAvLyDRhNC+0L3QvtCy0L7QtSDQvtGB0LLQtdGJ0LXQvdC40LUgMSDQvdCwINCy0YHRjiDRgdGG0LXQvdGDXG5cbiAgICAgICAgICAgICAgICB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSh3b3JsZF9Ob3JtYWwpO1xuICAgICAgICAgICAgICAgIGZsb2F0IGsgPSBjbGFtcChrX3ZlcnRleCwgMC4wLCAxLjApO1xuXG4gICAgICAgICAgICAgICAgdmVjMyB0b19saWdodCA9IHVfbGlnaHRXb3JsZFBvc2l0aW9uIC0gayAqIHdvcmxkX1ZlcnRleDtcbiAgICAgICAgICAgICAgICB0b19saWdodCA9IG5vcm1hbGl6ZSh0b19saWdodCk7XG5cbiAgICAgICAgICAgICAgICBmbG9hdCBjb3NfYW5nbGUgPSBkb3Qobm9ybWFsLHRvX2xpZ2h0KTsgXG4gICAgICAgICAgICAgICAgY29zX2FuZ2xlID0gY2xhbXAoY29zX2FuZ2xlLCAwLjAsIDEuMCk7XG5cbiAgICAgICAgICAgIGRpZmZ1c2VfY29sb3IgPSBjb3NfYW5nbGUgKiB1X2xpZ2h0Q29sb3IgKiB1X2ludGVuc2l0eTsgIFxuXG4gICAgICAgICAgICAgICAgdmVjMyB0b19WaWV3ID0gdV92aWV3V29ybGRQb3NpdGlvbiAtICBrICogd29ybGRfVmVydGV4O1xuICAgICAgICAgICAgICAgIHRvX1ZpZXcgPSBub3JtYWxpemUodG9fVmlldyk7XG5cbiAgICAgICAgICAgICAgICB2ZWMzIGhhbGZWZWN0b3IgPSBub3JtYWxpemUodG9fVmlldyArIHRvX2xpZ2h0KTtcblxuICAgICAgICAgICAgc3BlY3VsYXJfY29sb3IgPSAocG93KGRvdChub3JtYWwsIGhhbGZWZWN0b3IpLCB1X3NoaW5pbmVzcykgKiB1X3NwZWN1bGFyQ29sb3IpICogdV9zcGVjdWxhckludDtcblxuICAgICAgICAgICAgaGlnaHAgdmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKTtcbiAgICAgICAgICAgIHRleGVsQ29sb3IgKj0gdl9jb2xvcjtcbiAgICAgICAgICAgIGNvbG9yID0gYW1iaWVudF9jb2xvcjsgXG4gICAgICAgICAgICBjb2xvciArPSB0ZXhlbENvbG9yLnJnYiAqIGRpZmZ1c2VfY29sb3I7IC8vIFxuICAgICAgICAgICAgY29sb3IgKz0gc3BlY3VsYXJfY29sb3I7XG5cbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIHRleGVsQ29sb3IuYSk7XG4gICAgICAgIH1cbiAgICBgLFxuICAgIH0sXG59O1xuXG5jbGFzcyBQaG9uZ01hdGVyaWFsIGV4dGVuZHMgQ29yZU1hdGVyaWFse1xuICAgIGNvbnN0cnVjdG9yKGRhdGEpe1xuICAgICAgICBzdXBlcihkYXRhKTtcbiAgICAgICAgdGhpcy5jcmVhdGVTaGFkZXJzQ29kZShzaGFkZXJzUGhvbmdNYXRlcmlhbCk7XG4gICAgfVxufVxuZXhwb3J0IHsgUGhvbmdNYXRlcmlhbCB9O1xuXG4vKlxuIC8vINC/0YDQvtCz0YDQsNC80LzQsCDQtdGB0YLRjCDQvdC1INC+0LTQuNC9INC40YHRgtC+0YfQvdC40Log0YHQstC10YLQsCBcblxuICAgICAgICAgICAgLy8gbGlnaHRfY29sb3IgPSB2ZWMzKDApO1xuICAgICAgICAgICAgLy8g0LTQu9GPINC60LDQttC00L7Qs9C+INC40YHRgtC+0YfQvdC40LrQsCDRgdCy0LXRgtCwIGxpZ2h0X2NvbG9yICs9IFxuICAgICAgICAgICAgICAgIC8vY29zX2FuZ2xlW9GC0LXQutGD0YnQtdCz0L4g0LjRgdGC0L7Rh9C90LjQutCwXSAqIHVfbGlnaHRDb2xvclvRgtC10LrRg9GJ0LXQs9C+INC40YHRgtC+0YfQvdC40LrQsF0gKiB1X2ludGVuc2l0eVvRgtC10LrRg9GJ0LXQs9C+INC40YHRgtC+0YfQvdC40LrQsF07XG4gICAgICAgICAgICAvLyBzcGVjdWxhciA9INCh0KPQnNCcKHNwZWN1bGFyX2xpZ2h0W9GC0LXQutGD0YnQtdCz0L4g0LjRgdGC0L7Rh9C90LjQutCwXSk7XG4gICAgICAgICAgICAvL3JzbHQgPSBhbWJpZW50X2NvbG9yID0odV9saWdodENvbG9yICogdV9pbnRlbnNpdHkpO1xuICAgICAgICAgICAgLy8gcnNsdCArPSB2X2NvbG9yLnJnYiAqIGxpZ2h0X2NvbG9yO1xuICAgICAgICAgICAgLy8gcnNsdCArPSBzcGVjdWxhcjtcblxuXG5cbiAgICAvLyBzcGVjdWxhciDQstCw0YDQuNCw0L3RgiDQstGL0YfQuNGB0LvQtdC90LjRjyBcbiAgICAgICAgICAgICAgICAgICAgcmVmbGVjdGlvbiA9IDIuMCAqIGNvc19hbmdsZSAqIG5vcm1hbCAtIHRvX2xpZ2h0O1xuICAgICAgICAgICAgICAgIHJlZmxlY3Rpb24gPSBub3JtYWxpemUocmVmbGVjdGlvbik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdG9fY2FtZXJhID0gLTEuMCAqIHZfVmVydGV4O1xuICAgICAgICAgICAgICAgIHRvX2NhbWVyYSA9IG5vcm1hbGl6ZSh0b19jYW1lcmEpO1xuXG4gICAgICAgICAgICAgICAgY29zX2FuZ2xlID0gZG90KHJlZmxlY3Rpb24sIHRvX2NhbWVyYSk7XG4gICAgICAgICAgICAgICAgY29zX2FuZ2xlID0gY2xhbXAoY29zX2FuZ2xlLCAwLjAsIDEuMCk7XG4gICAgICAgICAgICAgICAgY29zX2FuZ2xlID0gcG93KGNvc19hbmdsZSwgdV9zaGluaW5lc3MpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGNvc19hbmdsZSA+IDAuMCkge1xuICAgICAgICAgICAgICAgICAgICBzcGVjdWxhcl9jb2xvciA9IHVfbGlnaHRDb2xvciAqIGNvc19hbmdsZTtcbiAgICAgICAgICAgICAgICAgICAgZGlmZnVzZV9jb2xvciA9IGRpZmZ1c2VfY29sb3IgKiAoMS4wIC0gY29zX2FuZ2xlKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNwZWN1bGFyX2NvbG9yID0gdmVjMygwLjAsIDAuMCwgMC4wKTtcbiAgICAgICAgICAgICAgICAgIH1cbiovXG5cbi8qXG5jb25zdCBzaGFkZXJzUGhvbmdNYXRlcmlhbCA9IHtcbiAgICBjb2xvcjp7XG4gICAgICAgIHZlcnRleDogYFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX25vcm1hbDtcbiAgICBcbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfbGlnaHRXb3JsZFBvc2l0aW9uO1xuICAgICAgICB1bmlmb3JtIHZlYzMgdV92aWV3V29ybGRQb3NpdGlvbjtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IG1vZGVsTWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgaW52VHJhbnNwTW9kZWxNYXRyaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgcHJvak1hdHJpeDtcblxuICAgICAgICB2YXJ5aW5nIHZlYzMgdl9ub3JtYWw7XG4gICAgICAgIHZhcnlpbmcgdmVjMyB2X3N1cmZhY2VUb0xpZ2h0O1xuICAgICAgICB2YXJ5aW5nIHZlYzMgdl9zdXJmYWNlVG9WaWV3O1xuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24ueHl6LDEuMCk7IFxuXG4gICAgICAgICAgICB2X25vcm1hbCA9ICBtYXQzKGludlRyYW5zcE1vZGVsTWF0cml4KSAqIGFfbm9ybWFsO1xuICAgICAgICAgICAgdmVjMyBzdXJmYWNlV29ybGRQb3NpdGlvbiA9IG1hdDMobW9kZWxNYXRyaXgpICogYV9wb3NpdGlvbi54eXo7XG4gICAgICAgICAgICB2X3N1cmZhY2VUb0xpZ2h0ID0gdV9saWdodFdvcmxkUG9zaXRpb24gLSBzdXJmYWNlV29ybGRQb3NpdGlvbjtcbiAgICAgICAgICAgIHZfc3VyZmFjZVRvVmlldyA9IHVfdmlld1dvcmxkUG9zaXRpb24gLSBzdXJmYWNlV29ybGRQb3NpdGlvbjtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgICAgIGZyYWdtZW50OiBgXG4gICAgICAgIHByZWNpc2lvbiBtZWRpdW1wIGZsb2F0O1xuICAgIFxuICAgICAgICB1bmlmb3JtIHZlYzQgdl9jb2xvcjtcbiAgICAgICAgdW5pZm9ybSB2ZWMzIHVfcmV2ZXJzZUxpZ2h0RGlyZWN0aW9uO1xuICAgICAgICB1bmlmb3JtIGZsb2F0IHVfc2hpbmluZXNzO1xuXG4gICAgICAgIHVuaWZvcm0gdmVjMyB1X2xpZ2h0Q29sb3I7XG4gICAgICAgIHVuaWZvcm0gdmVjMyB1X3NwZWN1bGFyQ29sb3I7XG5cbiAgICAgICAgdmFyeWluZyB2ZWMzIHZfbm9ybWFsO1xuICAgICAgICB2YXJ5aW5nIHZlYzMgdl9zdXJmYWNlVG9MaWdodDtcbiAgICAgICAgdmFyeWluZyB2ZWMzIHZfc3VyZmFjZVRvVmlldztcblxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICB2ZWMzIG5vcm1hbCA9IG5vcm1hbGl6ZSh2X25vcm1hbCk7XG4gICAgICAgICAgICB2ZWMzIHN1cmZhY2VUb0xpZ2h0RGlyZWN0aW9uID0gbm9ybWFsaXplKHZfc3VyZmFjZVRvTGlnaHQpO1xuICAgICAgICAgICAgdmVjMyBzdXJmYWNlVG9WaWV3RGlyZWN0aW9uID0gbm9ybWFsaXplKHZfc3VyZmFjZVRvVmlldyk7XG4gICAgICAgICAgICB2ZWMzIGhhbGZWZWN0b3IgPSBub3JtYWxpemUoc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24gKyBzdXJmYWNlVG9WaWV3RGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgLy9mbG9hdCBsaWdodCA9IGRvdChub3JtYWwsIHVfcmV2ZXJzZUxpZ2h0RGlyZWN0aW9uKTtcbiAgICAgICAgICAgIGZsb2F0IGxpZ2h0ID0gZG90KG5vcm1hbCwgc3VyZmFjZVRvTGlnaHREaXJlY3Rpb24pO1xuICAgICAgICAgICAgZmxvYXQgc3BlY3VsYXIgPSAwLjA7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChsaWdodCA+IDAuMCkge1xuICAgICAgICAgICAgICBzcGVjdWxhciA9IHBvdyhkb3Qobm9ybWFsLCBoYWxmVmVjdG9yKSwgdV9zaGluaW5lc3MpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IgPSB2X2NvbG9yO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yLnJnYiAqPSAgbGlnaHQgKiB1X2xpZ2h0Q29sb3I7XG4gICAgICAgICAgICBnbF9GcmFnQ29sb3IucmdiICs9IHNwZWN1bGFyICogdV9zcGVjdWxhckNvbG9yO1xuICAgICAgICB9XG4gICAgYCxcbiAgICB9LFxuICAgIG1hcDp7XG4gICAgICAgIHZlcnRleDogYFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhVmVydGV4Tm9ybWFsO1xuICAgIFxuICAgICAgICB1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgcHJvak1hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHVOb3JtYWxNYXRyaXg7XG4gICAgXG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkxpZ2h0aW5nO1xuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24ueHl6LDEuMCk7IC8vXG4gICAgICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIGhpZ2hwIHZlYzMgYW1iaWVudExpZ2h0ID0gdmVjMygwLjMsIDAuMywgMC4zKTtcbiAgICAgICAgICAgIGhpZ2hwIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yID0gdmVjMygxLCAxLCAxKTtcbiAgICAgICAgICAgIGhpZ2hwIHZlYzMgZGlyZWN0aW9uYWxWZWN0b3IgPSBub3JtYWxpemUodmVjMygwLjg1LCAwLjgsIDAuNzUpKTtcbiAgICAgIFxuICAgICAgICAgICAgaGlnaHAgdmVjNCB0cmFuc2Zvcm1lZE5vcm1hbCA9IHVOb3JtYWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhOb3JtYWwsIDEuMCk7XG4gICAgICBcbiAgICAgICAgICAgIGhpZ2hwIGZsb2F0IGRpcmVjdGlvbmFsID0gbWF4KGRvdCh0cmFuc2Zvcm1lZE5vcm1hbC54eXosIGRpcmVjdGlvbmFsVmVjdG9yKSwgMC4wKTtcbiAgICAgICAgICAgIHZMaWdodGluZyA9IGFtYmllbnRMaWdodCArIChkaXJlY3Rpb25hbExpZ2h0Q29sb3IgKiBkaXJlY3Rpb25hbCk7XG4gICAgICAgIH1cbiAgICBgLFxuICAgICAgICBmcmFnbWVudDogYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcblxuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkxpZ2h0aW5nO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzIgdlRleHR1cmVDb29yZDtcblxuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBoaWdocCB2ZWM0IHRleGVsQ29sb3IgPSB0ZXh0dXJlMkQodVNhbXBsZXIsIHZUZXh0dXJlQ29vcmQpO1xuICAgICAgICAgICAgZ2xfRnJhZ0NvbG9yID0gdmVjNCh0ZXhlbENvbG9yLnJnYiAqIHZMaWdodGluZywgdGV4ZWxDb2xvci5hKTtcbiAgICAgICAgfVxuICAgIGAsXG4gICAgfSxcbiAgICBtYXBBbmRDb2xvcjp7XG4gICAgICAgIHZlcnRleDogYFxuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhX3Bvc2l0aW9uO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMiBhVGV4dHVyZUNvb3JkO1xuICAgICAgICBhdHRyaWJ1dGUgdmVjMyBhVmVydGV4Tm9ybWFsO1xuICAgIFxuICAgICAgICB1bmlmb3JtIG1hdDQgbW9kZWxNYXRyaXg7XG4gICAgICAgIHVuaWZvcm0gbWF0NCB2aWV3TWF0cml4O1xuICAgICAgICB1bmlmb3JtIG1hdDQgcHJvak1hdHJpeDtcbiAgICAgICAgdW5pZm9ybSBtYXQ0IHVOb3JtYWxNYXRyaXg7XG4gICAgXG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMiB2VGV4dHVyZUNvb3JkO1xuICAgICAgICB2YXJ5aW5nIGhpZ2hwIHZlYzMgdkxpZ2h0aW5nO1xuICAgIFxuICAgICAgICB2b2lkIG1haW4oKSB7XG4gICAgICAgICAgICBnbF9Qb3NpdGlvbiA9IHByb2pNYXRyaXggKiB2aWV3TWF0cml4ICogbW9kZWxNYXRyaXggKiB2ZWM0KGFfcG9zaXRpb24ueHl6LDEuMCk7IC8vXG4gICAgICAgICAgICB2VGV4dHVyZUNvb3JkID0gYVRleHR1cmVDb29yZDtcbiAgICAgICAgICAgIGhpZ2hwIHZlYzMgYW1iaWVudExpZ2h0ID0gdmVjMygwLjMsIDAuMywgMC4zKTtcbiAgICAgICAgICAgIGhpZ2hwIHZlYzMgZGlyZWN0aW9uYWxMaWdodENvbG9yID0gdmVjMygxLCAxLCAxKTtcbiAgICAgICAgICAgIGhpZ2hwIHZlYzMgZGlyZWN0aW9uYWxWZWN0b3IgPSBub3JtYWxpemUodmVjMygwLjg1LCAwLjgsIDAuNzUpKTtcbiAgICAgIFxuICAgICAgICAgICAgaGlnaHAgdmVjNCB0cmFuc2Zvcm1lZE5vcm1hbCA9IHVOb3JtYWxNYXRyaXggKiB2ZWM0KGFWZXJ0ZXhOb3JtYWwsIDEuMCk7XG4gICAgICBcbiAgICAgICAgICAgIGhpZ2hwIGZsb2F0IGRpcmVjdGlvbmFsID0gbWF4KGRvdCh0cmFuc2Zvcm1lZE5vcm1hbC54eXosIGRpcmVjdGlvbmFsVmVjdG9yKSwgMC4wKTtcbiAgICAgICAgICAgIHZMaWdodGluZyA9IGFtYmllbnRMaWdodCArIChkaXJlY3Rpb25hbExpZ2h0Q29sb3IgKiBkaXJlY3Rpb25hbCk7XG4gICAgICAgIH1cbiAgICBgLFxuICAgICAgICBmcmFnbWVudDogYFxuICAgICAgICBwcmVjaXNpb24gbWVkaXVtcCBmbG9hdDtcblxuICAgICAgICB1bmlmb3JtIHNhbXBsZXIyRCB1U2FtcGxlcjtcbiAgICAgICAgdW5pZm9ybSB2ZWM0IHZfY29sb3I7XG5cbiAgICAgICAgdmFyeWluZyBoaWdocCB2ZWMyIHZUZXh0dXJlQ29vcmQ7XG4gICAgICAgIHZhcnlpbmcgaGlnaHAgdmVjMyB2TGlnaHRpbmc7XG5cbiAgICBcbiAgICAgICAgdm9pZCBtYWluKCkge1xuICAgICAgICAgICAgaGlnaHAgdmVjNCB0ZXhlbENvbG9yID0gdGV4dHVyZTJEKHVTYW1wbGVyLCB2VGV4dHVyZUNvb3JkKSpjb2xvcjtcbiAgICAgICAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQodGV4ZWxDb2xvci5yZ2IgKiB2TGlnaHRpbmcsIHRleGVsQ29sb3IuYSk7XG4gICAgICAgIH1cbiAgICBgLFxuICAgIH1cbn07XG5cblxuKi9cblxuIiwiXG5jbGFzcyBDb3JlTGlnaHQge1xuICAgIGNvbnN0cnVjdG9yKCl7XG4gICAgICAgIHRoaXMudHlwZSA9ICdsaWdodCc7XG4gICAgICAgIHRoaXMuY29sb3IgPSBbXTtcbiAgICAgICAgdGhpcy5pbnRlbnNpdHkgPSAwO1xuICAgIH1cbiAgICBjcmVhdGVEYXRhVG9XZWJnbCAoKXtcbiAgICAgICAgaWYgKHRoaXMudHlwZUxpZ2h0ID09ICdhbWJpZW50Jyl7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgaW50ZW5zaXR5OnRoaXMuaW50ZW5zaXR5LFxuICAgICAgICAgICAgICAgICAgICB0eXBlOiB0aGlzLnR5cGVMaWdodCxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogdGhpcy5jb2xvcixcbiAgICAgICAgICAgICAgICAgICAgaW50ZW5zaXR5OiB0aGlzLmludGVuc2l0eSxcbiAgICAgICAgICAgICAgICAgICAgcG9zaXRpb25MaWdodDogdGhpcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgc2hpbmllc3M6IHRoaXMuc2hpbmluZXNzLFxuICAgICAgICAgICAgICAgICAgICBzcGVjdWxhckNvbG9yOiB0aGlzLnNwZWN1bGFyQ29sb3IsXG4gICAgICAgICAgICAgICAgICAgIHNwZWN1bGFySW50OiB0aGlzLnNwZWN1bGFySW50LFxuICAgICAgICAgICAgICAgICAgICBrX3ZlcnRleDogdGhpcy5rX3ZlcnRleCxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogdGhpcy50eXBlTGlnaHQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0IHsgQ29yZUxpZ2h0IH07IiwiaW1wb3J0IHsgQ29yZUxpZ2h0IH0gZnJvbSBcIi4vQ29yZUxpZ2h0XCI7XG5cbmNsYXNzIEFtYmllbnRMaWdodCBleHRlbmRzIENvcmVMaWdodCB7XG4gICAgY29uc3RydWN0b3IgKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZUxpZ2h0ID0gJ2FtYmllbnQnO1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBBbWJpZW50TGlnaHQgfTsiLCJpbXBvcnQgeyBDb29yZGluYXRlczNEIH0gZnJvbSBcIi4uL0Nvb3JkaW5hdGVzM0RcIjtcbmltcG9ydCB7IENvcmVMaWdodCB9IGZyb20gXCIuL0NvcmVMaWdodFwiO1xuLypcbmNvbnN0IEJMQUNLID0gWzAuMCwgMC4wLCAwLjBdO1xuY29uc3QgV0hJVEUgPSBbMS4wLCAxLjAsIDEuMF07XG5jb25zdCBSRUQgICA9IFsxLjAsIDAuMCwgMC4wXTtcbmNvbnN0IEdSRUVOID0gWzAuMCwgMS4wLCAwLjBdO1xuY29uc3QgQkxVRSAgPSBbMC4wLCAwLjAsIDEuMF07XG5jb25zdCBZRUxMT1cgPSBbMC42LDEuMCwwLjVdOy8vKDYwLDEwMCUsNTAlKVxuKi9cbmNsYXNzIERpcmVjdGlvbmFsTGlnaHQgZXh0ZW5kcyBDb3JlTGlnaHR7XG4gICAgY29uc3RydWN0b3IgKCl7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMudHlwZUxpZ2h0ID0gJ2RpcmVjdGlvbmFsJztcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBDb29yZGluYXRlczNEKCk7XG4gICAgICAgIHRoaXMuc3BlY3VsYXJDb2xvciA9IFsxLjAsMS4wLDEuMF07XG4gICAgICAgIHRoaXMuc3BlY3VsYXJJbnQgPSAxLjA7XG4gICAgICAgIHRoaXMuc2hpbmluZXNzID0gMTAuMDtcbiAgICAgICAgdGhpcy5rX3ZlcnRleCA9IDAuMDtcbiAgICB9XG5cblxufVxuXG5leHBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0IH07IiwiaW1wb3J0IHsgQ29vcmRpbmF0ZXMzRCB9IGZyb20gXCIuLi9Db29yZGluYXRlczNEXCI7XG5pbXBvcnQgeyBDb3JlTGlnaHQgfSBmcm9tIFwiLi9Db3JlTGlnaHRcIjtcblxuY2xhc3MgUG9pbnRMaWdodCBleHRlbmRzIENvcmVMaWdodHtcbiAgICBjb25zdHJ1Y3RvciAoKXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy50eXBlTGlnaHQgPSAncG9pbnQnOyBcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IG5ldyBDb29yZGluYXRlczNEKCk7XG4gICAgICAgIHRoaXMuc3BlY3VsYXJDb2xvciA9IFsxLjAsMS4wLDEuMF07XG4gICAgICAgIHRoaXMuc3BlY3VsYXJJbnQgPSAxLjA7XG4gICAgICAgIHRoaXMuc2hpbmluZXNzID0gMTAuMDtcbiAgICAgICAgdGhpcy5rX3ZlcnRleCA9IDEuMDtcbiAgICB9XG59XG5cbmV4cG9ydCB7IFBvaW50TGlnaHQgfTsiLCJpbXBvcnQgeyBDb29yZGluYXRlczNEIH0gZnJvbSBcIi4uL0Nvb3JkaW5hdGVzM0RcIjtcbmltcG9ydCB7IENvcmVHZW9tZXRyeSB9IGZyb20gXCIuL0NvcmVHZW9tZXRyeVwiO1xuXG5jbGFzcyBQbGFuZUdlb21ldHJ5IGV4dGVuZHMgQ29yZUdlb21ldHJ5IHtcbiAgICBjb25zdHJ1Y3RvciAodyxoLHgseSx6KXtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydCA9IG5ldyBDb29yZGluYXRlczNEKHgseSx6KTtcbiAgICAgICAgdGhpcy53ID0gdztcbiAgICAgICAgdGhpcy5oID0gaDtcbiAgICB9XG4gICAgY3JlYXRlVmVydGV4KCl7XG4gICAgICAgIGxldCB4MCA9IHRoaXMuc3RhcnQueDtcbiAgICAgICAgbGV0IHgxID0geDArIHRoaXMudztcbiAgICAgICAgbGV0IHkwID0gdGhpcy5zdGFydC55O1xuICAgICAgICBsZXQgeTEgPSB5MCt0aGlzLmg7IFxuICAgICAgICBsZXQgejAgPSB0aGlzLnN0YXJ0Lno7XG5cbiAgICAgICAgbGV0IHZlcnRleCA9ICBbXG4gICAgICAgICAgICB4MCx5MCx6MCxcbiAgICAgICAgICAgIHgxLHkwLHowLFxuICAgICAgICAgICAgeDAseTEsejAsXG4gICAgICBcbiAgICAgICAgICAgIHgwLHkxLHowLFxuICAgICAgICAgICAgeDEseTAsejAsXG4gICAgICAgICAgICB4MSx5MSx6MCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgbWFwQ29yZDJEID0gW1xuICAgICAgICAgICAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLFxuICAgICAgICAgICAgMC4wLCAgMS4wLFxuICAgICAgICAgICAgMC4wLCAgMS4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMS4wIFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBmcm9udE5vcm1hbHMgPSBbXG4gICAgICAgICAgICAwLjAsICAwLjAsICAxLjAsXG4gICAgICAgICAgICAwLjAsICAwLjAsICAxLjAsXG4gICAgICAgICAgICAwLjAsICAwLjAsICAxLjAsXG5cbiAgICAgICAgICAgIDAuMCwgIDAuMCwgIDEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgIDEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgIDEuMCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgYmFja05vcm1hbHMgPSBbXG4gICAgICAgICAgICAwLjAsICAwLjAsIC0xLjAsXG4gICAgICAgICAgICAwLjAsICAwLjAsIC0xLjAsXG4gICAgICAgICAgICAwLjAsICAwLjAsIC0xLjAsXG5cbiAgICAgICAgICAgIDAuMCwgIDAuMCwgLTEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgLTEuMCxcbiAgICAgICAgICAgIDAuMCwgIDAuMCwgLTEuMCxcbiAgICAgICAgXTtcbiAgICAgICAgY29uc3QgdG9wTm9ybWFscyA9IFtcbiAgICAgICAgICAgIDAuMCwgIC0xLjAsICAwLjAsXG4gICAgICAgICAgICAwLjAsICAtMS4wLCAgMC4wLFxuICAgICAgICAgICAgMC4wLCAgLTEuMCwgIDAuMCxcblxuICAgICAgICAgICAgMC4wLCAgLTEuMCwgIDAuMCxcbiAgICAgICAgICAgIDAuMCwgIC0xLjAsICAwLjAsXG4gICAgICAgICAgICAwLjAsICAtMS4wLCAgMC4wLFxuICAgICAgICBdO1xuICAgICAgICBjb25zdCBib3R0b21Ob3JtYWxzID0gW1xuICAgICAgICAgICAgMC4wLCAxLjAsICAwLjAsXG4gICAgICAgICAgICAwLjAsIDEuMCwgIDAuMCxcbiAgICAgICAgICAgIDAuMCwgMS4wLCAgMC4wLFxuXG4gICAgICAgICAgICAwLjAsIDEuMCwgIDAuMCxcbiAgICAgICAgICAgIDAuMCwgMS4wLCAgMC4wLFxuICAgICAgICAgICAgMC4wLCAxLjAsICAwLjAsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IGxlZnROb3JtYWxzID0gW1xuICAgICAgICAgICAgLTEuMCwgIDAuMCwgIDAuMCxcbiAgICAgICAgICAgIC0xLjAsICAwLjAsICAwLjAsXG4gICAgICAgICAgICAtMS4wLCAgMC4wLCAgMC4wLFxuXG4gICAgICAgICAgICAtMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgLTEuMCwgIDAuMCwgIDAuMCxcbiAgICAgICAgICAgIC0xLjAsICAwLjAsICAwLjAsXG4gICAgICAgIF07XG4gICAgICAgIGNvbnN0IHJpZ2h0Tm9ybWFscyA9IFtcbiAgICAgICAgICAgIDEuMCwgIDAuMCwgIDAuMCxcbiAgICAgICAgICAgIDEuMCwgIDAuMCwgIDAuMCxcbiAgICAgICAgICAgIDEuMCwgIDAuMCwgIDAuMCxcblxuICAgICAgICAgICAgMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICAgICAgMS4wLCAgMC4wLCAgMC4wLFxuICAgICAgICBdO1xuXG4gICAgICAgIHRoaXMucGFydHNHZW9tZXRyeSA9IFtcbiAgICAgICAgICAgIHRoaXMuY3JlYXRlR2VvbWV0cnkoJ3BhcnQnLHZlcnRleCxtYXBDb3JkMkQsZnJvbnROb3JtYWxzKSxcbiAgICAgICAgXTtcblxuICAgICAgICAvL3ZlcnRleCA9IHZlcnRleC5jb25jYXQoZnJvbnRSZWN0LmNvcmQsYmFja1JlY3QuY29yZCx0b3BWZXJ0ZXgsYm90dG9tVmVydGV4LGxlZnRWZXJ0ZXgscmlnaHRWZXJ0ZXgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJ0c0dlb21ldHJ5O1xuICAgIH1cblxufVxuXG5leHBvcnQgeyBQbGFuZUdlb21ldHJ5IH07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbmltcG9ydCB7IEJhc2ljTWF0ZXJpYWwgfSBmcm9tIFwiLi9tYXRlcmlhbC9CYXNpY01hdGVyaWFsXCI7XG5pbXBvcnQgeyBDYW1lcmEgfSBmcm9tIFwiLi9jYW1lcmEvQ2FtZXJhXCI7XG5pbXBvcnQgeyBNZXNoIH0gZnJvbSBcIi4vTWVzaFwiO1xuaW1wb3J0IHsgUmVjdGFuZ3VsYXJHZW9tZXRyeSB9IGZyb20gXCIuL2dlb21ldHJ5L1JlY3Rhbmd1bGFyR2VvbWV0cnlcIjtcbmltcG9ydCB7IFNjZW5lIH0gZnJvbSBcIi4vU2NlbmVcIjtcbmltcG9ydCB7IFRyaWFuZ2xlR2VvbWV0cnkgfSBmcm9tIFwiLi9nZW9tZXRyeS9UcmlhbmdsZUdlb21ldHJ5XCI7XG5pbXBvcnQgeyBXZWJHbFJlbmRlciB9IGZyb20gXCIuL1dlYkdsUmVuZGVyXCI7XG5pbXBvcnQgeyBCb3hHZW9tZXRyeSB9IGZyb20gXCIuL2dlb21ldHJ5L0JveEdlb21ldHJ5XCI7XG5pbXBvcnQgeyBUZXh0dXJlTWF0ZXJpYWwgfSBmcm9tIFwiLi9tYXRlcmlhbC9UZXh0dXJlTWF0ZXJpYWxcIjtcbmltcG9ydCB7IEdyYWRpZW50TWF0ZXJpYWwgfSBmcm9tIFwiLi9tYXRlcmlhbC9HcmFkaWVudE1hdGVyaWFsXCI7XG5pbXBvcnQgeyBNYXRyaXggfSBmcm9tIFwiLi9tYXRoL01hdHJpeFwiO1xuaW1wb3J0IHsgTW9ub2Nocm9tZUNvbG9yIH0gZnJvbSBcIi4vbWF0ZXJpYWwvTW9ub2Nocm9tZUNvbG9yXCI7XG5pbXBvcnQgeyBQaG9uZ01hdGVyaWFsIH0gZnJvbSBcIi4vbWF0ZXJpYWwvUGhvbmdNYXRlcmlhbFwiO1xuaW1wb3J0IHsgQW1iaWVudExpZ2h0IH0gZnJvbSBcIi4vbGlnaHQvQW1iaWVudExpZ2h0XCI7XG5pbXBvcnQgeyBEaXJlY3Rpb25hbExpZ2h0IH0gZnJvbSBcIi4vbGlnaHQvRGlyZWN0aW9uYWxMaWdodFwiO1xuaW1wb3J0IHsgUG9pbnRMaWdodCB9IGZyb20gXCIuL2xpZ2h0L1BvaW50TGlnaHRcIjtcbmltcG9ydCB7IFBsYW5lR2VvbWV0cnkgfSBmcm9tIFwiLi9nZW9tZXRyeS9QbGFuZUdlb21ldHJ5XCI7XG5cbmNvbnN0IEJMQUNLID0gWzAuMCwgMC4wLCAwLjAsIDEuMF07XG5jb25zdCBXSElURSA9IFsxLjAsIDEuMCwgMS4wLCAxLjBdO1xuY29uc3QgUkVEICAgPSBbMS4wLCAwLjAsIDAuMCwgMS4wXTtcbmNvbnN0IEdSRUVOID0gWzAuMCwgMS4wLCAwLjAsIDEuMF07XG5jb25zdCBCTFVFICA9IFswLjAsIDAuMCwgMS4wLCAxLjBdO1xuXG5sZXQgaW1hZ2UyID0gbmV3IEltYWdlKCk7XG5pbWFnZTIuc3JjID0gJy4uL3RpbGVzLmpwZWcnO1xuXG5sZXQgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbi8vaW1hZ2Uuc3JjID0gJy4uL0RldnNfVGl0bGVfQ2FyZC5wbmcnO1xuaW1hZ2Uuc3JjID0gJy4uL3dlc3R3b3JsZC00LmpwZWcnO1xuXG4gLy9pbWFnZTIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCl7XG4gICAgbWFpbihpbWFnZSxpbWFnZTIpO1xuICB9O1xuIC8vfTtcblxuZnVuY3Rpb24gbWFpbiAoaW1hZ2UxLGltYWdlMil7XG4gIGxldCBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2FudmFzJyk7XG4gIGNhbnZhcy53aWR0aCA9IHdpbmRvdy5pbm5lcldpZHRoICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIGNhbnZhcy5oZWlnaHQgPSB3aW5kb3cuaW5uZXJIZWlnaHQgKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgXG4gIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLGZ1bmN0aW9uKCl7XG4gICAgY2FudmFzLndpZHRoID0gd2luZG93LmlubmVyV2lkdGggKiB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbztcbiAgICBjYW52YXMuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0ICogd2luZG93LmRldmljZVBpeGVsUmF0aW87XG4gIH0pO1xuICBcbiAgLy8gbGV0IGltYWdlMyA9IG5ldyBJbWFnZSgpO1xuICAvLyBpbWFnZTMuc3JjID0gJy4uL3RpbGVzLmpwZWcnO1xuICBcbiAgLy8gbGV0IGltYWdlID0gbmV3IEltYWdlKCk7XG4gIC8vIC8vaW1hZ2Uuc3JjID0gJy4uL0RldnNfVGl0bGVfQ2FyZC5wbmcnO1xuICAvLyBpbWFnZS5zcmMgPSAnLi4vd2VzdHdvcmxkLTQuanBlZyc7XG4gIFxuICBcbiAgLy93ZXN0d29ybGQtNC5qcGVnXG4gIFxuICBsZXQgY2FtZXJhID0gbmV3IENhbWVyYTsgXG4gIFxuICAvL2NhbWVyYS5wZXJzcGVjdGl2ZVNldHQuZm92ID0gOTAgKiBNYXRoLlBJLzE4MDtcbiAgLy9jYW1lcmEucGVyc3BlY3RpdmVTZXR0LnpOZWFyID0gMC41O1xuICBjYW1lcmEucGVyc3BlY3RpdmVTZXR0LnpGYXIgPSA2MDAwO1xuICBjYW1lcmEucGVyc3BlY3RpdmVTZXR0LmFzcGVjdCA9IGNhbnZhcy53aWR0aC9jYW52YXMuaGVpZ2h0O1xuICBcbiAgY2FtZXJhLm9ydG9ncmFwaGljU2V0dC5yaWdodCA9IGNhbnZhcy53aWR0aDtcbiAgY2FtZXJhLm9ydG9ncmFwaGljU2V0dC5ib3R0b20gPSBjYW52YXMuaGVpZ2h0O1xuICBjYW1lcmEub3J0b2dyYXBoaWNTZXR0LmxlZnQgPSAwO1xuICBjYW1lcmEub3J0b2dyYXBoaWNTZXR0LnRvcCA9IDA7XG4gIGNhbWVyYS5vcnRvZ3JhcGhpY1NldHQubmVhciA9IC0zMDAwO1xuICBjYW1lcmEub3J0b2dyYXBoaWNTZXR0LmZhciA9IDMwMDA7XG4gIFxuICBsZXQgZmkgPSAwO1xuICBsZXQgcmVuZGVyZXIgPSBuZXcgV2ViR2xSZW5kZXIoY2FudmFzKTtcbiAgXG4gIGxldCBib3hHZW9tID0gbmV3IEJveEdlb21ldHJ5KDIwMCwyMDAsMjAwLC0yMDAvMiwtMjAwLzIsLTIwMC8yKTtcbiAgbGV0IHBsYW5lR2VvbWV0cnkgPSBuZXcgUGxhbmVHZW9tZXRyeSgxMDAwLDEwMDAsLTEwMDAvMiwtMTAwMC8yKTsvLy0xMDAwLzIsLTEwMDAvMiwtMTAwMC8yXG4gIFxuICBsZXQgYm94TWF0ZXJpYWxEYXRhID0ge1xuICAgIGNvbG9yOiBbMS4wLCAwLjAsIDAuNSwgMC41XSxcbiAgfTtcbiAgbGV0IHRleHRNYXRlcmlhbHYxID0ge1xuICAgIG1hcDogaW1hZ2UxXG4gIH07XG4gIGxldCB0ZXh0TWF0ZXJpYWx2MiA9IHtcbiAgICBtYXA6IGltYWdlMSxcbiAgICBjb2xvcjogUkVELFxuICB9O1xuICBsZXQgdGV4dE1hdGVyaWFsdjMgPSB7XG4gICAgbWFwOiBpbWFnZTIsXG4gICAgLy9jb2xvcjogR1JFRU4sXG4gIH07XG5cbiAgbGV0IGJveE1hdGVyaWFsdjIgPSBbXG4gICAgbmV3IEJhc2ljTWF0ZXJpYWwgKHtjb2xvcjogUkVEfSksXG4gICAgbmV3IEJhc2ljTWF0ZXJpYWwgKHtjb2xvcjogR1JFRU59KSxcbiAgICBuZXcgQmFzaWNNYXRlcmlhbCAoe2NvbG9yOiBCTFVFfSksXG4gICAgbmV3IEJhc2ljTWF0ZXJpYWwgKHtjb2xvcjogWzEuMCwgMC4wLCAwLjUsIDAuNV19KSxcbiAgICBuZXcgQmFzaWNNYXRlcmlhbCAoe2NvbG9yOiBbMC41LCAxLCAwLjgsIDFdfSksXG4gICAgbmV3IEJhc2ljTWF0ZXJpYWwgKHtjb2xvcjogWzAuMDQsIDAuOTYsIDAuOTYsIDFdfSlcbiAgXTsgXG4gIGxldCBib3hNYXRlcmlhbHY1ID0gW1xuICAgIG5ldyBQaG9uZ01hdGVyaWFsICh7Y29sb3I6IFJFRH0pLFxuICAgIG5ldyBQaG9uZ01hdGVyaWFsICh7Y29sb3I6IEdSRUVOfSksXG4gICAgbmV3IFBob25nTWF0ZXJpYWwgKHtjb2xvcjogQkxVRX0pLFxuICAgIG5ldyBQaG9uZ01hdGVyaWFsICh7Y29sb3I6IFsxLjAsIDAuMCwgMC41LCAxXX0pLFxuICAgIG5ldyBQaG9uZ01hdGVyaWFsICh7Y29sb3I6IFswLjUsIDEsIDAuOCwgMV19KSxcbiAgICBuZXcgUGhvbmdNYXRlcmlhbCAoe2NvbG9yOiBbMC4wNCwgMC45NiwgMC45NiwgMV19KSxcbiAgXTtcbiAgbGV0IGJveE1hdGVyaWFsdjMgPSBbXG4gICAgbmV3IEJhc2ljTWF0ZXJpYWwgKHtjb2xvcjogWzEuMCwgMC4wLCAwLjUsIDEuMF19KSxcbiAgICBuZXcgQmFzaWNNYXRlcmlhbCh0ZXh0TWF0ZXJpYWx2MSlcbiAgICAvL25ldyBCYXNpY01hdGVyaWFsICh7Y29sb3I6IFswLjUsIDEsIDAsIDFdfSksXG4gICAgLy9uZXcgQmFzaWNNYXRlcmlhbCAoe2NvbG9yOiBbMSwgMCwgMCwgMV19KSxcbiAgICAvL25ldyBCYXNpY01hdGVyaWFsICh7Y29sb3I6IFswLjUsIDEsIDAsIDFdfSksXG4gICAgLy9uZXcgQmFzaWNNYXRlcmlhbCAoe2NvbG9yOiBbMC4zLCAxLCAwLCAxXX0pLFxuICBdO1xuICBsZXQgY29sb3JCb3hFZGdlcyA9IFtcbiAgICBbMSwgMCwgMCwgMV0sXG4gICAgWzAsIDAsIDEsIDFdLFxuICAgIFswLjUsIDEsIDAsIDFdLFxuICAgIFswLjMsIDEsIDAsIDFdLFxuICAgIFswLjIsIDAuNiwgMC44LCAxXSxcbiAgICBbMCwgMC41LCAwLjcsIDFdXG4gIF07XG4gIFxuICBsZXQgYm94TWF0ZXJpYWx2MSA9IG5ldyBCYXNpY01hdGVyaWFsKGJveE1hdGVyaWFsRGF0YSk7XG4gIGxldCBwbGFuZW1hdGVyaWFsID0gbmV3IFBob25nTWF0ZXJpYWwodGV4dE1hdGVyaWFsdjMpO1xuICBsZXQgYm94TWF0ZXJpYWx2NCA9IG5ldyBQaG9uZ01hdGVyaWFsKHRleHRNYXRlcmlhbHYyKTtcbiAgbGV0IGJveE1hdGVyaWFsdjYgPSBuZXcgUGhvbmdNYXRlcmlhbCh0ZXh0TWF0ZXJpYWx2MSk7XG4gIGxldCBib3hNYXRlcmlhbHY3ID0gbmV3IFBob25nTWF0ZXJpYWwoYm94TWF0ZXJpYWxEYXRhKTtcbiAgLy9jb25zb2xlLmxvZyhib3hNYXRlcmlhbHY0KTtcblxuICBsZXQgYm94MiA9IG5ldyBNZXNoKGJveEdlb20sYm94TWF0ZXJpYWx2NCk7XG4gIGxldCBib3gzID0gbmV3IE1lc2goYm94R2VvbSxib3hNYXRlcmlhbHY2KTtcbiAgbGV0IHBsYW5lID0gbmV3IE1lc2gocGxhbmVHZW9tZXRyeSxwbGFuZW1hdGVyaWFsKTtcbiAgbGV0IGJveCA9IG5ldyBNZXNoKGJveEdlb20sYm94TWF0ZXJpYWx2Mik7XG5cblxuICBcbiAgLy9jb25zb2xlLmxvZyhib3gpO1xuICBcbiAgbGV0IHNjZW5lID0gbmV3IFNjZW5lKCk7XG4gIFxuICBzY2VuZS5iYWNrZ3JvdW5kID0gQkxBQ0s7XG4gIFxuICBjb25zdCBsaWdodCA9IG5ldyBBbWJpZW50TGlnaHQoKTtcbiAgbGlnaHQuY29sb3IgPSBbMS4wLCAxLjAsIDEuMF07XG4gIGxpZ2h0LmludGVuc2l0eSA9IDAuMDtcbiAgXG4gIGNvbnN0IGxpZ2h0MiA9IG5ldyBEaXJlY3Rpb25hbExpZ2h0KCk7XG4gIGxpZ2h0Mi5wb3NpdGlvbi54ID0gMDtcbiAgbGlnaHQyLnBvc2l0aW9uLnkgPSAwO1xuICBsaWdodDIucG9zaXRpb24ueiA9IDIwMDtcbiAgbGlnaHQyLmNvbG9yID0gWzEuMCwgMS4wLCAxLjBdO1xuICBsaWdodDIuaW50ZW5zaXR5ID0gMS4wO1xuICBcbiAgXG4gIGNvbnN0IGxpZ2h0MyA9IG5ldyBQb2ludExpZ2h0KCk7XG4gIC8vIGxpZ2h0My5wb3NpdGlvbi55ID0gLTMwMDtcbiAgLy8gbGlnaHQzLnBvc2l0aW9uLnogPSAzMDA7XG4gIGxpZ2h0My5jb2xvciA9IFsxLjAsIDEuMCwgMS4wXTtcbiAgbGlnaHQzLmludGVuc2l0eSA9IDEuMDtcbiAgbGlnaHQzLnNoaW5pbmVzcyA9IDIwMC4wO1xuICBsaWdodDMuc3BlY3VsYXJJbnQgPSAxLjA7XG4gIFxuICBzY2VuZS5hZGQobGlnaHQpO1xuICBzY2VuZS5hZGQobGlnaHQzKTtcbiAgc2NlbmUuYWRkKHBsYW5lKTtcbiAgc2NlbmUuYWRkKGJveCk7XG4gIHNjZW5lLmFkZChib3gyKTtcbiAgc2NlbmUuYWRkKGJveDMpO1xuXG4gIFxuICBwbGFuZS5yb3RhdGlvbi54ID0gTWF0aC5QSS8yOy8vMTgwO1xuICAvL3BsYW5lLnJvdGF0aW9uLnggPSAyKk1hdGguUEk7Ly8xODA7XG4gIHBsYW5lLnNjYWxlLnggPSA0O1xuICBwbGFuZS5zY2FsZS55ID0gNDtcbiAgY2FtZXJhLnJvdGF0aW9uLnggID0gMC40O1xuICAvL2NhbWVyYS5yb3RhdGlvbi55ID0gNDU7XG4gIFxuICBsZXQgdFByZXYgPSAwO1xuICBsZXQgZFQgPSAwO1xuICBcbiAgXG4gIC8vIGltYWdlLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAvLyAgIHJlbmRlcigpO1xuICAvLyB9O1xuICAvLyBpbWFnZS5vbmxvYWQgPSBmdW5jdGlvbigpIHtcbiAgLy8gICBpbWFnZTIub25sb2FkID0gZnVuY3Rpb24oKXtcbiAgLy8gICAgIHJlbmRlcigpO1xuICAvLyAgIH07XG4gIC8vIH07XG4gIFxuICByZW5kZXIoKTtcbiAgZnVuY3Rpb24gcmVuZGVyICgpeyAgLy8gcmVuZGVyIHRhcmdldCBcblxuICAgIGRUID0gICh3aW5kb3cucGVyZm9ybWFuY2Uubm93KCktdFByZXYpKjYwLzEwMDA7XG4gICAgLy9jb25zb2xlLmxvZyhkVCx3aW5kb3cucGVyZm9ybWFuY2Uubm93KCksdFByZXYpO1xuICAgIGZpICs9IDAuMDA1KmRUO1xuICBcbiAgICBib3gucG9zaXRpb24ueCA9IDA7Ly9jYW52YXMud2lkdGgvMjtcbiAgICBib3gucG9zaXRpb24ueSA9IDA7Ly9jYW52YXMuaGVpZ2h0LzI7XG4gICAgYm94LnBvc2l0aW9uLnogPSAtNTAwOy8vTWF0aC5zaW4oZmkpKjE1MDA7XG4gIFxuICAgIGJveDIucG9zaXRpb24ueCA9IDUwMDsvL2NhbnZhcy53aWR0aC8yO1xuICAgIGJveDIucG9zaXRpb24ueSA9IDA7Ly9jYW52YXMuaGVpZ2h0LzI7XG4gICAgYm94Mi5wb3NpdGlvbi56ID0gLTUwMDsvL01hdGguc2luKGZpKSoxNTAwO1xuICBcbiAgICBib3gzLnBvc2l0aW9uLnggPSAtNTAwOy8vY2FudmFzLndpZHRoLzI7XG4gICAgYm94My5wb3NpdGlvbi55ID0gMDsvL2NhbnZhcy5oZWlnaHQvMjtcbiAgICBib3gzLnBvc2l0aW9uLnogPSAtNTAwOy8vTWF0aC5zaW4oZmkpKjE1MDA7XG4gICAgLy9jb25zb2xlLmxvZyhib3gucG9zaXRpb24ueik7XG4gIFxuICAgIHBsYW5lLnBvc2l0aW9uLnggPSAwOy8vY2FudmFzLndpZHRoLzI7XG4gICAgcGxhbmUucG9zaXRpb24ueSA9IC02MDA7Ly9jYW52YXMuaGVpZ2h0LzI7XG4gICAgcGxhbmUucG9zaXRpb24ueiA9IC01MDA7Ly9NYXRoLnNpbihmaSkqMTUwMDtcbiAgICAvL3BsYW5lLnJvdGF0aW9uLnggPSAtZmk7Ly8xODA7XG4gICAgLy9jb25zb2xlLmxvZyhwbGFuZS5yb3RhdGlvbi54KTtcbiAgXG4gICAgLy9wbGFuZS5yb3RhdGlvbi54ID0gZmk7XG4gIFxuICAgIGxpZ2h0My5wb3NpdGlvbi55ID0gMzAwOyAvLyogKE1hdGguY29zKGZpKSk7XG4gICAgbGlnaHQzLnBvc2l0aW9uLnogPSAzMDAgKiAoTWF0aC5jb3MoZmkpKTtcbiAgICAvL2NvbnNvbGUubG9nKGxpZ2h0My5wb3NpdGlvbi56KTtcbiAgXG4gICAgYm94LnJvdGF0aW9uLnggPSBmaTtcbiAgICBib3gucm90YXRpb24ueSA9IGZpO1xuICAgIGJveC5yb3RhdGlvbi56ID0gZmk7XG4gIFxuICAgIGJveDIucm90YXRpb24ueCA9IE1hdGguUEkvMjtcbiAgICAvL2JveDIucm90YXRpb24ueSA9IGZpO1xuICAgIC8vYm94Mi5yb3RhdGlvbi56ID0gZmk7XG4gIFxuICAgIC8vYm94My5yb3RhdGlvbi54ID0gLWZpO1xuICAgIC8vYm94My5yb3RhdGlvbi55ID0gZmk7XG4gICAgLy9ib3gzLnJvdGF0aW9uLnogPSAtZmk7XG4gIFxuICAgIC8vY2FtZXJhLnJvdGF0aW9uLnggPSAtZmk7XG4gICAgLy9jb25zb2xlLmxvZyhjYW1lcmEucm90YXRpb24ueCk7XG4gIFxuICAgIGNhbWVyYS5wb3NpdGlvbi55ID0gNTAwO1xuICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTAwO1xuICBcbiAgICBjYW1lcmEub3J0b2dyYXBoaWNTZXR0LnJpZ2h0ID0gY2FudmFzLndpZHRoO1xuICAgIGNhbWVyYS5vcnRvZ3JhcGhpY1NldHQuYm90dG9tID0gY2FudmFzLmhlaWdodDtcbiAgXG4gICAgY2FtZXJhLnBlcnNwZWN0aXZlU2V0dC5hc3BlY3QgPSBjYW52YXMud2lkdGgvY2FudmFzLmhlaWdodDtcbiAgXG4gICAgcmVuZGVyZXIucmVuZGVyKHNjZW5lLGNhbWVyYSk7XG4gIFxuICAgIHRQcmV2ID0gd2luZG93LnBlcmZvcm1hbmNlLm5vdygpO1xuICBcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUocmVuZGVyKTtcbiAgfVxufVxuXG5cblxuIl0sInNvdXJjZVJvb3QiOiIifQ==\\n//# sourceURL=webpack-internal:///0\\n\")}]);","extractedComments":[]}